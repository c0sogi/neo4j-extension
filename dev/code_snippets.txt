### neo4j_extension\typing.py
from typing import Any, TypedDict

class Property(TypedDict):
    property: str
    type: str

class Triplet(TypedDict):
    start: str
    type: str
    end: str

class StructuredSchemaMetadata(TypedDict):
    constraint: list[dict[str, Any]]
    index: list[dict[str, Any]]

class GraphSchema(TypedDict):
    node_props: dict[str, list[Property]]
    rel_props: dict[str, list[Property]]
    relationships: list[Triplet]
    metadata: StructuredSchemaMetadata

==========

### neo4j_extension\utils.py
import unicodedata
from typing import Iterable, LiteralString, cast
from typing import List as PyList
DELIMITERS = {'[', ']', '(', ')', '{', '}', ',', ':', "'", '"'}

def escape_identifier(key: str) -> LiteralString:
    """
    Escape a property key for use in a Cypher query.
    If the key is a valid identifier, it is returned as is.
    Otherwise, it is escaped with backticks.
    """
    if all((unicodedata.category(char).startswith(('L', 'N')) or char == '_' for char in key)):
        return cast(LiteralString, key)
    escaped = key.replace('`', '``')
    return cast(LiteralString, f'`{escaped}`')

def get_safe_query(query: LiteralString, **labels: str) -> LiteralString:
    """
    Return a Cypher query with the given labels as parameters.

    The query should contain placeholders for the labels in the format
    `{label_name}`. The labels will be escaped and inserted into the query.

    Example:
    ```python
    query = "MATCH (n:{label}) RETURN n"
    labels = {"label": "Person"}
    print(_get_type_query(query, **labels))
    ```

    Args:
        query: The Cypher query with placeholders for labels.
        **labels: The labels to insert into the query.

    Returns:
        The Cypher query with the labels inserted.
    """
    s = query.format(**{key: escape_identifier(value) for key, value in labels.items()})
    return cast(LiteralString, s)

def tokenize_cypher_expression(expr: str) -> PyList[str]:
    """
    Simple Cypher expression tokenizer.
    """
    tokens: PyList[str] = []
    i = 0
    length = len(expr)
    while i < length:
        c = expr[i]
        if c.isspace():
            i += 1
            continue
        if c in ('(', ')', '[', ']', '{', '}', ',', ':'):
            tokens.append(c)
            i += 1
            continue
        if c in ("'", '"'):
            quote_char = c
            start_index = i
            i += 1
            escaped = False
            while i < length:
                if escaped:
                    escaped = False
                    i += 1
                elif i < length and expr[i] == '\\':
                    escaped = True
                    i += 1
                elif i < length and expr[i] == quote_char:
                    i += 1
                    break
                else:
                    i += 1
            str_token = expr[start_index:i]
            tokens.append(str_token)
            continue
        start_index = i
        while i < length:
            if expr[i].isspace() or expr[i] in DELIMITERS:
                break
            i += 1
        sub = expr[start_index:i]
        tokens.append(sub)
    return tokens

def split_by_comma_top_level(tokens: PyList[str]) -> PyList[str]:
    """
    Split tokens by ',' at the top level.
    """
    result: PyList[str] = []
    current_tokens: PyList[str] = []
    stack: PyList[str] = []
    level = 0
    matching = {'(': ')', '[': ']', '{': '}'}
    for t in tokens:
        if t in ('(', '[', '{'):
            stack.append(t)
            level += 1
            current_tokens.append(t)
        elif t in (')', ']', '}'):
            if not stack:
                raise ValueError(f'Unmatched closing bracket: {t}')
            top = stack.pop()
            level -= 1
            if matching[top] != t:
                raise ValueError(f'Mismatched bracket: {t}')
            current_tokens.append(t)
        elif t == ',' and level == 0:
            result.append(''.join(current_tokens).strip())
            current_tokens = []
        else:
            current_tokens.append(t)
    if stack:
        raise ValueError(f'Unclosed bracket(s) in expression: {stack}')
    if current_tokens:
        result.append(''.join(current_tokens).strip())
    return result

def generate_new_id(existing_ids: Iterable[int]) -> int:
    """Assign a new ID that is not in the existing IDs."""
    return max(existing_ids, default=0) + 1

==========

### neo4j_extension\__init__.py
from .bolt import AsyncDriverKwargs, DriverKwargs, Neo4jConnection, SessionKwargs, with_async_session, with_session
from .graph import AddNodeAction, AddPropertyAction, AddRelationshipAction, Entity, EntityModel, Graph, GraphAction, GraphModel, Node, NodeModel, OrphanConnectionProposal, OrphanNodesFoundException, PropertyModel, PropertyType, Relationship, RelationshipModel, RemoveNodeAction, RemovePropertyAction, RemoveRelationshipAction, UpdateNodeLabelsAction, UpdatePropertyAction, UpdateRelationshipTypeAction, apply_actions
from .types import Neo4jBoolean, Neo4jByteArray, Neo4jDate, Neo4jDuration, Neo4jFloat, Neo4jInteger, Neo4jList, Neo4jLocalDateTime, Neo4jLocalTime, Neo4jMap, Neo4jNull, Neo4jPoint, Neo4jString, Neo4jType, Neo4jZonedDateTime, Neo4jZonedTime, PointValue, PythonType, convert_cypher_to_neo4j, convert_neo4j_to_python, convert_python_to_neo4j, ensure_neo4j_type, ensure_python_type, get_neo4j_property_type_name
from .typing import GraphSchema, Property, StructuredSchemaMetadata, Triplet
from .utils import escape_identifier, generate_new_id, get_safe_query, split_by_comma_top_level, tokenize_cypher_expression
__all__ = ['Neo4jConnection', 'with_session', 'with_async_session', 'DriverKwargs', 'AsyncDriverKwargs', 'SessionKwargs', 'AddNodeAction', 'AddPropertyAction', 'AddRelationshipAction', 'apply_actions', 'Entity', 'EntityModel', 'Graph', 'GraphAction', 'GraphModel', 'Node', 'NodeModel', 'OrphanConnectionProposal', 'OrphanNodesFoundException', 'PropertyModel', 'PropertyType', 'Relationship', 'RemoveNodeAction', 'RemovePropertyAction', 'RemoveRelationshipAction', 'UpdateRelationshipTypeAction', 'UpdateNodeLabelsAction', 'UpdatePropertyAction', 'RelationshipModel', 'Neo4jBoolean', 'Neo4jByteArray', 'Neo4jFloat', 'Neo4jInteger', 'Neo4jList', 'Neo4jMap', 'Neo4jNull', 'Neo4jString', 'Neo4jPoint', 'PointValue', 'Neo4jDate', 'Neo4jDuration', 'Neo4jType', 'Neo4jLocalDateTime', 'Neo4jLocalTime', 'Neo4jZonedDateTime', 'Neo4jZonedTime', 'PythonType', 'convert_neo4j_to_python', 'ensure_neo4j_type', 'get_neo4j_property_type_name', 'convert_cypher_to_neo4j', 'convert_python_to_neo4j', 'ensure_python_type', 'Neo4jBoolean', 'Neo4jByteArray', 'Neo4jFloat', 'Neo4jInteger', 'Neo4jList', 'Neo4jMap', 'Neo4jNull', 'Neo4jString', 'Neo4jPoint', 'PointValue', 'Neo4jDate', 'Neo4jDuration', 'Neo4jType', 'Neo4jLocalDateTime', 'Neo4jLocalTime', 'Neo4jZonedDateTime', 'Neo4jZonedTime', 'PythonType', 'convert_neo4j_to_python', 'ensure_neo4j_type', 'get_neo4j_property_type_name', 'convert_cypher_to_neo4j', 'convert_python_to_neo4j', 'ensure_python_type', 'GraphSchema', 'StructuredSchemaMetadata', 'Property', 'Triplet', 'escape_identifier', 'get_safe_query', 'generate_new_id', 'split_by_comma_top_level', 'tokenize_cypher_expression']

==========

### neo4j_extension\bolt\connection.py
import logging
from dataclasses import dataclass, field
from functools import wraps
from os import environ
from typing import TYPE_CHECKING, Any, Awaitable, Callable, Concatenate, Final, Iterable, Literal, LiteralString, Optional, ParamSpec, Self, TypeAlias, TypedDict, TypeVar, cast
import neo4j
import neo4j.auth_management
from neo4j import AsyncDriver, AsyncGraphDatabase, AsyncManagedTransaction, AsyncSession, Driver, GraphDatabase, ManagedTransaction, Session
from ..graph.structure import Graph, Node, Relationship
from ..types._utils import ensure_python_type
from ..typing import GraphSchema, Property
from ..utils import escape_identifier
if TYPE_CHECKING:
    import ssl

    class SessionKwargs(TypedDict, total=False):
        connection_acquisition_timeout: float
        max_transaction_retry_time: float
        database: Optional[str]
        fetch_size: int
        impersonated_user: Optional[str]
        bookmarks: Optional[Iterable[str] | neo4j.api.Bookmarks]
        default_access_mode: str
        bookmark_manager: Optional[neo4j.api.BookmarkManager]
        auth: neo4j.api._TAuth
        notifications_min_severity: Optional[neo4j._api.T_NotificationMinimumSeverity]
        notifications_disabled_categories: Optional[Iterable[neo4j._api.T_NotificationDisabledCategory]]
        notifications_disabled_classifications: Optional[Iterable[neo4j._api.T_NotificationDisabledCategory]]
        initial_retry_delay: float
        retry_delay_multiplier: float
        retry_delay_jitter_factor: float

    class DriverKwargs(TypedDict, total=False):
        uri: str
        auth: neo4j.api._TAuth | neo4j.auth_management.AuthManager
        max_connection_lifetime: float
        liveness_check_timeout: Optional[float]
        max_connection_pool_size: int
        connection_timeout: float
        trust: Literal['TRUST_ALL_CERTIFICATES', 'TRUST_SYSTEM_CA_SIGNED_CERTIFICATES']
        resolver: Callable[[neo4j.addressing.Address], Iterable[neo4j.addressing.Address]] | Callable[[neo4j.addressing.Address], Iterable[neo4j.addressing.Address]]
        encrypted: bool
        trusted_certificates: neo4j.security.TrustStore
        client_certificate: Optional[neo4j.security.ClientCertificate | neo4j.security.ClientCertificateProvider]
        ssl_context: Optional[ssl.SSLContext]
        user_agent: str
        keep_alive: bool
        notifications_min_severity: Optional[neo4j._api.T_NotificationMinimumSeverity]
        notifications_disabled_categories: Optional[Iterable[neo4j._api.T_NotificationDisabledCategory]]
        notifications_disabled_classifications: Optional[Iterable[neo4j._api.T_NotificationDisabledCategory]]
        warn_notification_severity: Optional[neo4j._api.T_NotificationMinimumSeverity]
        telemetry_disabled: bool
        connection_acquisition_timeout: float
        max_transaction_retry_time: float
        initial_retry_delay: float
        retry_delay_multiplier: float
        retry_delay_jitter_factor: float
        database: Optional[str]
        fetch_size: int
        impersonated_user: Optional[str]
        bookmark_manager: Optional[neo4j.api.BookmarkManager]

    class AsyncDriverKwargs(TypedDict, total=False):
        uri: str
        auth: neo4j.api._TAuth | neo4j.auth_management.AsyncAuthManager
        max_connection_lifetime: float
        liveness_check_timeout: Optional[float]
        max_connection_pool_size: int
        connection_timeout: float
        trust: Literal['TRUST_ALL_CERTIFICATES', 'TRUST_SYSTEM_CA_SIGNED_CERTIFICATES']
        resolver: Callable[[neo4j.addressing.Address], Iterable[neo4j.addressing.Address]] | Callable[[neo4j.addressing.Address], Iterable[neo4j.addressing.Address]]
        encrypted: bool
        trusted_certificates: neo4j.security.TrustStore
        client_certificate: Optional[neo4j.security.ClientCertificate | neo4j.security.ClientCertificateProvider]
        ssl_context: Optional[ssl.SSLContext]
        user_agent: str
        keep_alive: bool
        notifications_min_severity: Optional[neo4j._api.T_NotificationMinimumSeverity]
        notifications_disabled_categories: Optional[Iterable[neo4j._api.T_NotificationDisabledCategory]]
        notifications_disabled_classifications: Optional[Iterable[neo4j._api.T_NotificationDisabledCategory]]
        warn_notification_severity: Optional[neo4j._api.T_NotificationMinimumSeverity]
        telemetry_disabled: bool
        connection_acquisition_timeout: float
        max_transaction_retry_time: float
        initial_retry_delay: float
        retry_delay_multiplier: float
        retry_delay_jitter_factor: float
        database: Optional[str]
        fetch_size: int
        impersonated_user: Optional[str]
        bookmark_manager: Optional[neo4j.api.BookmarkManager]
else:
    SessionKwargs: TypeAlias = dict
    DriverKwargs: TypeAlias = dict
    AsyncDriverKwargs: TypeAlias = dict
NODE_PROPERTIES_QUERY: Final = '\nCALL apoc.meta.data()\nYIELD label, other, elementType, type, property\nWHERE NOT type = "RELATIONSHIP"\n    AND elementType = "node"\n    AND NOT label IN $EXCLUDED_LABELS\nWITH label AS nodeLabels, collect({property: property, type: type}) AS properties\nRETURN {labels: nodeLabels, properties: properties} AS output\n'
REL_PROPERTIES_QUERY: Final = '\nCALL apoc.meta.data()\nYIELD label, other, elementType, type, property\nWHERE NOT type = "RELATIONSHIP"\n    AND elementType = "relationship"\n    AND NOT label IN $EXCLUDED_RELS\nWITH label AS nodeLabels, collect({property: property, type: type}) AS properties\nRETURN {type: nodeLabels, properties: properties} AS output\n'
REL_QUERY: Final = '\nCALL apoc.meta.data()\nYIELD label, other, elementType, type, property\nWHERE type = "RELATIONSHIP"\n    AND elementType = "node"\nUNWIND other AS other_node\nWITH *\nWHERE NOT label IN $EXCLUDED_LABELS\n    AND NOT other_node IN $EXCLUDED_LABELS\nRETURN {start: label, type: property, end: toString(other_node)} AS output\n'
INDEX_RES_QUERY: Final = "\nCALL apoc.schema.nodes()\nYIELD label, properties, type, size, valuesSelectivity\nWHERE type = 'RANGE'\nRETURN *, size * valuesSelectivity as distinctValues\n"
ENV_NEO4J_HOST: str = environ.get('NEO4J_HOST', 'localhost')
ENV_NEO4J_USER: str = environ.get('NEO4J_USER', 'neo4j')
ENV_NEO4J_PASSWORD: str = environ.get('NEO4J_PASSWORD', '')
ENV_NEO4J_PORT: str = environ.get('NEO4J_PORT', '7474')
ENV_NEO4J_BOLT_PORT: str = environ.get('NEO4J_BOLT_PORT', '7687')
P = ParamSpec('P')
T = TypeVar('T')
Neo4j = TypeVar('Neo4j', bound='Neo4jConnection')
logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(levelname)s] %(message)s')

class with_session:
    """
    동기용 데코레이터 모음.
    """

    @staticmethod
    def scope(method: Callable[Concatenate[Neo4j, Session, P], T]) -> Callable[Concatenate[Neo4j, P], T]:

        @wraps(method)
        def wrapper(self: Neo4j, *args: P.args, **kwargs: P.kwargs) -> T:
            with self.connection.session(**self.session_kwargs) as session:
                return method(self, session, *args, **kwargs)
        return wrapper

    @staticmethod
    def readwrite_transaction(method: Callable[Concatenate[Neo4j, ManagedTransaction, P], T]) -> Callable[Concatenate[Neo4j, P], T]:

        @wraps(method)
        def wrapper(self: Neo4j, *args: P.args, **kwargs: P.kwargs) -> T:
            with self.connection.session(**self.session_kwargs) as session:
                return session.execute_write(lambda tx: method(self, tx, *args, **kwargs))
        return wrapper

    @staticmethod
    def readonly_transaction(method: Callable[Concatenate[Neo4j, ManagedTransaction, P], T]) -> Callable[Concatenate[Neo4j, P], T]:

        @wraps(method)
        def wrapper(self: Neo4j, *args: P.args, **kwargs: P.kwargs) -> T:
            with self.connection.session(**self.session_kwargs) as session:
                return session.execute_read(lambda tx: method(self, tx, *args, **kwargs))
        return wrapper

class with_async_session:
    """
    비동기용 데코레이터 모음.
    """

    @staticmethod
    def scope(method: Callable[Concatenate[Neo4j, AsyncSession, P], Awaitable[T]]) -> Callable[Concatenate[Neo4j, P], Awaitable[T]]:

        @wraps(method)
        async def wrapper(self: Neo4j, *args: P.args, **kwargs: P.kwargs) -> T:
            async with (await self.aconnection).session(**self.session_kwargs) as session:
                return await method(self, session, *args, **kwargs)
        return wrapper

    @staticmethod
    def readwrite_transaction(method: Callable[Concatenate[Neo4j, AsyncManagedTransaction, P], Awaitable[T]]) -> Callable[Concatenate[Neo4j, P], Awaitable[T]]:

        @wraps(method)
        async def wrapper(self: Neo4j, *args: P.args, **kwargs: P.kwargs) -> T:
            async with (await self.aconnection).session(**self.session_kwargs) as session:
                return await session.execute_write(lambda tx: method(self, tx, *args, **kwargs))
        return wrapper

    @staticmethod
    def readonly_transaction(method: Callable[Concatenate[Neo4j, AsyncManagedTransaction, P], Awaitable[T]]) -> Callable[Concatenate[Neo4j, P], Awaitable[T]]:

        @wraps(method)
        async def wrapper(self: Neo4j, *args: P.args, **kwargs: P.kwargs) -> T:
            async with (await self.aconnection).session(**self.session_kwargs) as session:
                return await session.execute_read(lambda tx: method(self, tx, *args, **kwargs))
        return wrapper

@dataclass
class Neo4jConnection:
    """
    Neo4j Connection

    Attributes:
        host: str
        port: str
        password: str
        user: str
        protocol: str
        driver: Optional[Driver]
        async_driver: Optional[AsyncDriver]
        driver_kwargs: DriverKwargs
        async_driver_kwargs: AsyncDriverKwargs
        session_kwargs: SessionKwargs
    """
    host: str = ENV_NEO4J_HOST
    port: str = ENV_NEO4J_BOLT_PORT
    password: str = ENV_NEO4J_PASSWORD
    user: str = ENV_NEO4J_USER
    protocol: str = 'neo4j'
    driver: Optional[Driver] = None
    async_driver: Optional[AsyncDriver] = None
    driver_kwargs: DriverKwargs = field(default_factory=DriverKwargs)
    async_driver_kwargs: AsyncDriverKwargs = field(default_factory=AsyncDriverKwargs)
    session_kwargs: SessionKwargs = field(default_factory=SessionKwargs)

    def connect(self) -> Driver:
        driver_kwargs: DriverKwargs = self.driver_kwargs.copy()
        if 'uri' not in driver_kwargs:
            driver_kwargs['uri'] = self.uri
        if 'auth' not in driver_kwargs:
            driver_kwargs['auth'] = self.auth
        logger.info(f'neo4j::connecting to `{self.uri}` ...')
        self.driver = GraphDatabase.driver(**driver_kwargs)
        self.driver.verify_connectivity()
        logger.info(f'neo4j::connected to `{self.uri}`')
        return self.driver

    async def aconnect(self) -> AsyncDriver:
        async_driver_kwargs: AsyncDriverKwargs = self.async_driver_kwargs.copy()
        if 'uri' not in async_driver_kwargs:
            async_driver_kwargs['uri'] = self.uri
        if 'auth' not in async_driver_kwargs:
            async_driver_kwargs['auth'] = self.auth
        logger.info(f'neo4j::connecting to `{self.uri}` ...')
        self.async_driver = AsyncGraphDatabase.driver(**async_driver_kwargs)
        await self.async_driver.verify_connectivity()
        logger.info(f'neo4j::connected to `{self.uri}`')
        return self.async_driver

    @property
    def connection(self) -> Driver:
        if self.driver is None:
            return self.connect()
        return self.driver

    @property
    async def aconnection(self) -> AsyncDriver:
        if self.async_driver is None:
            return await self.aconnect()
        return self.async_driver

    @property
    def uri(self) -> str:
        return f'{self.protocol}://{self.host}:{self.port}'

    @property
    def auth(self) -> tuple[str, str]:
        return (self.user, self.password)

    def close(self) -> None:
        if self.driver is not None:
            self.driver.close()
            self.driver = None
            logger.info(f'neo4j::closed connection to `{self.uri}`')

    async def aclose(self) -> None:
        if self.async_driver is not None:
            await self.async_driver.close()
            self.async_driver = None
            logger.info(f'neo4j::closed connection to `{self.uri}`')

    def __enter__(self) -> Self:
        return self

    def __exit__(self, *args: Any) -> None:
        self.close()

    async def __aenter__(self) -> Self:
        await self.aconnect()
        return self

    async def __aexit__(self, *args: Any) -> None:
        await self.aclose()

    @with_session.scope
    def get_graph_schema(self, session: Session, excluded_labels: Optional[list[str]]=None, excluded_rels: Optional[list[str]]=None) -> GraphSchema:
        if excluded_labels is None:
            excluded_labels = ['_Bloom_Perspective_', '_Bloom_Scene_']
        if excluded_rels is None:
            excluded_rels = ['_Bloom_HAS_SCENE_']

        def run_query(query: str, params: Optional[dict[str, Any]]=None) -> list[dict[str, Any]]:
            result = session.run(cast(LiteralString, query), params or {})
            return [record.data() for record in result]
        node_properties_res = run_query(query=NODE_PROPERTIES_QUERY, params={'EXCLUDED_LABELS': excluded_labels})
        rel_properties_res = run_query(query=REL_PROPERTIES_QUERY, params={'EXCLUDED_RELS': excluded_rels})
        relationships_res = run_query(query=REL_QUERY, params={'EXCLUDED_LABELS': excluded_labels})
        try:
            constraint_res: list[dict[str, Any]] = run_query('SHOW CONSTRAINTS')
        except neo4j.exceptions.Neo4jError as e:
            logger.warning(f'Cannot read constraints: {e}')
            constraint_res = []
        try:
            index_res = run_query(INDEX_RES_QUERY)
        except neo4j.exceptions.Neo4jError as e:
            logger.warning(f'Cannot read indexes: {e}')
            index_res = []
        structured_schema: GraphSchema = {'node_props': {item['output']['labels']: item['output']['properties'] for item in node_properties_res}, 'rel_props': {item['output']['type']: item['output']['properties'] for item in rel_properties_res}, 'relationships': [item['output'] for item in relationships_res], 'metadata': {'constraint': constraint_res, 'index': index_res}}
        return structured_schema

    def get_formatted_graph_schema(self, excluded_labels: Optional[list[str]]=None, excluded_rels: Optional[list[str]]=None) -> str:
        return self.format_graph_schema(self.get_graph_schema(excluded_labels=excluded_labels, excluded_rels=excluded_rels))

    @staticmethod
    def format_graph_schema(graph_schema: GraphSchema) -> str:
        lines: list[str] = []
        lines.append('### Node properties')
        node_props: dict[str, list[Property]] = graph_schema.get('node_props', {})
        for label, props in node_props.items():
            lines.append(f'- {label}')
            for p in props:
                lines.append(f'  * {p['property']}: {p['type']}')
        lines.append('\n### Relationship properties')
        rel_props: dict[str, list[Property]] = graph_schema.get('rel_props', {})
        for rtype, rprops in rel_props.items():
            lines.append(f'- {rtype}')
            for rp in rprops:
                lines.append(f'  * {rp['property']}: {rp['type']}')
        lines.append('\n### Relationships')
        rels = graph_schema.get('relationships', [])
        for rel_dict in rels:
            lines.append(f'- (:{rel_dict['start']})-[:{rel_dict['type']}]->(:{rel_dict['end']})')
        return '\n'.join(lines)

    def _do_upsert_node(self, tx: ManagedTransaction, node: Node) -> dict:
        """
        Merge node based on globalId if present.
        """
        if node.globalId:
            query: LiteralString = f'\n                MERGE (n {{ globalId: $globalId }})\n                SET n += $props\n                SET n:{node.safe_labelstring}\n                RETURN n\n            '
            result = tx.run(query, globalId=node.globalId, props=node.to_python_props()).single()
        else:
            query: LiteralString = f'\n                CREATE (n:{node.safe_labelstring})\n                SET n = $props\n                RETURN n\n            '
            result = tx.run(query, props=node.to_python_props()).single()
        return result['n'] if result else {}

    def _do_upsert_relationship(self, tx: ManagedTransaction, relationship: Relationship) -> dict:
        """
        Merge relationship based on relationship.globalId if present.
        Upsert start_node, end_node first with globalId only.
        """
        self._do_upsert_node(tx, relationship.start_node)
        self._do_upsert_node(tx, relationship.end_node)
        if relationship.globalId:
            query: LiteralString = f'\n                MATCH (start {{globalId: $startNodeGlobalId}})\n                MATCH (end   {{globalId: $endNodeGlobalId}})\n                MERGE (start)-[r:{escape_identifier(relationship.rel_type)} {{ globalId: $relGlobalId }}]->(end)\n                SET r += $props\n                RETURN r\n            '
            result = tx.run(query, startNodeGlobalId=relationship.start_node.globalId, endNodeGlobalId=relationship.end_node.globalId, relGlobalId=relationship.globalId, props=relationship.to_python_props()).single()
        else:
            query: LiteralString = f'\n                MATCH (start {{globalId: $startNodeGlobalId}})\n                MATCH (end   {{globalId: $endNodeGlobalId}})\n                CREATE (start)-[r:{escape_identifier(relationship.rel_type)}]->(end)\n                SET r = $props\n                RETURN r\n            '
            result = tx.run(query, startNodeGlobalId=relationship.start_node.globalId, endNodeGlobalId=relationship.end_node.globalId, props=relationship.to_python_props()).single()
        return result['r'] if result else {}

    @with_session.readwrite_transaction
    def get_all_nodes(self, tx: ManagedTransaction) -> list[Node]:
        """Get all nodes in the database"""
        result = tx.run('MATCH (n) RETURN n')
        return [Node.from_neo4j(record['n']) for record in result]

    @with_async_session.readwrite_transaction
    async def aget_all_nodes(self, tx: AsyncManagedTransaction) -> list[Node]:
        """Get all nodes in the database (async)"""
        result = await tx.run('MATCH (n) RETURN n')
        return [Node.from_neo4j(record['n']) async for record in result]

    @with_session.readwrite_transaction
    def get_all_relationships(self, tx: ManagedTransaction) -> list[Relationship]:
        """Get all relationships in the database"""
        result = tx.run('MATCH ()-[r]->() RETURN r')
        return [Relationship.from_neo4j(record['r']) for record in result]

    @with_async_session.readwrite_transaction
    async def aget_all_relationships(self, tx: AsyncManagedTransaction) -> list[Relationship]:
        """Get all relationships in the database (async)"""
        result = await tx.run('MATCH ()-[r]->() RETURN r')
        return [Relationship.from_neo4j(record['r']) async for record in result]

    @with_session.readwrite_transaction
    def get_all_graph(self, tx: ManagedTransaction) -> Graph:
        """Get all nodes and relationships in the database"""
        result = tx.run('MATCH (n)-[r]->(m) RETURN n, r, m')
        return Graph.from_neo4j(result.graph())

    @with_async_session.readwrite_transaction
    async def aget_all_graph(self, tx: AsyncManagedTransaction) -> Graph:
        """Get all nodes and relationships in the database (async)"""
        result = await tx.run('MATCH (n)-[r]->(m) RETURN n, r, m')
        return Graph.from_neo4j(await result.graph())

    @with_session.readwrite_transaction
    def clear_all(self, tx: ManagedTransaction) -> None:
        """Clear all data in the database"""
        tx.run('MATCH (n) DETACH DELETE n')

    @with_async_session.readwrite_transaction
    async def aclear_all(self, tx: AsyncManagedTransaction) -> None:
        """Clear all data in the database (async)"""
        await tx.run('MATCH (n) DETACH DELETE n')

    @with_session.readwrite_transaction
    def upsert_node(self, tx: ManagedTransaction, node: Node) -> dict:
        """Upsert a node in a transaction"""
        return self._do_upsert_node(tx, node)

    @with_session.readwrite_transaction
    def upsert_relationship(self, tx: ManagedTransaction, rel: Relationship) -> dict:
        """Upsert a relationship in a transaction"""
        return self._do_upsert_relationship(tx, rel)

    @with_session.readwrite_transaction
    def upsert_graph(self, tx: ManagedTransaction, graph: Graph) -> None:
        """
        Upsert all Node, Relationship in a Graph within a single transaction.
        """
        for node in graph.nodes.values():
            self._do_upsert_node(tx, node)
        for rel in graph.relationships.values():
            self._do_upsert_relationship(tx, rel)

    @with_session.readonly_transaction
    def find_node_by_global_id(self, tx: ManagedTransaction, global_id: str) -> Optional[Node]:
        """
        주어진 global_id를 가진 노드를 조회하여 Node 객체로 반환한다.
        없으면 None.
        """
        query: LiteralString = '\n        MATCH (n {globalId: $globalId})\n        RETURN n\n        '
        record = tx.run(query, globalId=global_id).single()
        if record is None:
            return None
        neo4j_node = record['n']
        return Node.from_neo4j(neo4j_node)

    @with_session.readonly_transaction
    def match_nodes(self, tx: ManagedTransaction, label: str, property_filters: Optional[dict[str, Any]]=None, limit: Optional[int]=None) -> list[Node]:
        """
        특정 레이블과 속성 조건으로 노드 목록을 조회한다.
        property_filters: { 'name': 'Alice', 'age': 20 }
        limit: 결과 개수 제한
        """
        where_clauses: list[LiteralString] = []
        params: dict[str, Any] = {}
        if property_filters:
            for idx, (k, v) in enumerate(property_filters.items()):
                param_key: LiteralString = cast(LiteralString, f'p{idx}')
                where_clauses.append(f'n.{escape_identifier(k)} = ${param_key}')
                params[param_key] = v
        where_str: LiteralString = ''
        if where_clauses:
            where_str = 'WHERE ' + ' AND '.join(where_clauses)
        limit_clause: LiteralString = ''
        if limit is not None:
            limit_clause = cast(LiteralString, f'LIMIT {limit}')
        query_str = f'\n        MATCH (n:{escape_identifier(label)})\n        {where_str}\n        RETURN n\n        {limit_clause}\n        '
        result = tx.run(cast(LiteralString, query_str), **params)
        nodes: list[Node] = []
        for record in result:
            neo4j_node = record['n']
            nodes.append(Node.from_neo4j(neo4j_node))
        return nodes

    @with_session.readonly_transaction
    def match_relationships(self, tx: ManagedTransaction, rel_type: str, property_filters: Optional[dict[str, Any]]=None, limit: Optional[int]=None) -> list[Relationship]:
        """
        특정 relationship 타입과 속성 조건을 만족하는 관계 목록을 조회한다.
        """
        where_clauses: list[LiteralString] = []
        params: dict[str, Any] = {}
        if property_filters:
            for idx, (k, v) in enumerate(property_filters.items()):
                param_key: LiteralString = cast(LiteralString, f'p{idx}')
                where_clauses.append(f'r.{escape_identifier(k)} = ${param_key}')
                params[param_key] = v
        where_str: LiteralString = ''
        if where_clauses:
            where_str = 'WHERE ' + ' AND '.join(where_clauses)
        limit_clause: LiteralString = ''
        if limit is not None:
            limit_clause = cast(LiteralString, f'LIMIT {limit}')
        query_str: LiteralString = f'\n        MATCH ()-[r:{escape_identifier(rel_type)}]->()\n        {where_str}\n        RETURN r\n        {limit_clause}\n        '
        result = tx.run(cast(LiteralString, query_str), **params)
        rels: list[Relationship] = []
        for record in result:
            neo4j_rel = record['r']
            rels.append(Relationship.from_neo4j(neo4j_rel))
        return rels

    @with_session.readonly_transaction
    def find_nodes_in_relationship(self, tx: ManagedTransaction, rel_type: str, property_filters: Optional[dict[str, Any]]=None, limit: Optional[int]=None) -> list[tuple[Node, Relationship, Node]]:
        """
        주어진 관계 타입(rel_type)과 property_filters를 만족하는
        (start_node, relationship, end_node) 목록을 조회한다.
        """
        where_clauses: list[LiteralString] = []
        params: dict[str, Any] = {}
        if property_filters:
            for idx, (k, v) in enumerate(property_filters.items()):
                param_key: LiteralString = cast(LiteralString, f'p{idx}')
                where_clauses.append(f'r.{escape_identifier(k)} = ${param_key}')
                params[param_key] = v
        where_str: LiteralString = ''
        if where_clauses:
            where_str = 'WHERE ' + ' AND '.join(where_clauses)
        limit_clause: LiteralString = ''
        if limit is not None:
            limit_clause = cast(LiteralString, f'LIMIT {limit}')
        query_str: LiteralString = f'\n        MATCH (start)-[r:{escape_identifier(rel_type)}]->(end)\n        {where_str}\n        RETURN start, r, end\n        {limit_clause}\n        '
        result = tx.run(query_str, **params)
        output: list[tuple[Node, Relationship, Node]] = []
        for record in result:
            start_node = Node.from_neo4j(record['start'])
            rel_obj = Relationship.from_neo4j(record['r'])
            end_node = Node.from_neo4j(record['end'])
            output.append((start_node, rel_obj, end_node))
        return output

    @with_session.readwrite_transaction
    def delete_node_by_global_id(self, tx: ManagedTransaction, global_id: str) -> None:
        """
        global_id를 가진 노드를 (관계까지) 삭제한다.
        """
        query: LiteralString = '\n        MATCH (n {globalId: $gid})\n        DETACH DELETE n\n        '
        tx.run(query, gid=global_id)

    @with_session.readwrite_transaction
    def delete_nodes_by_label(self, tx: ManagedTransaction, label: str, property_filters: Optional[dict[str, Any]]=None) -> None:
        """
        특정 레이블과 속성 조건을 만족하는 노드들을 일괄 삭제한다.
        (관계까지 포함)
        """
        where_clauses: list[LiteralString] = []
        params: dict[str, Any] = {}
        if property_filters:
            for idx, (k, v) in enumerate(property_filters.items()):
                param_key: LiteralString = cast(LiteralString, f'pf{idx}')
                where_clauses.append(f'n.{escape_identifier(k)} = ${param_key}')
                params[param_key] = v
        where_str: LiteralString = ''
        if where_clauses:
            where_str = 'WHERE ' + ' AND '.join(where_clauses)
        query_str: LiteralString = f'\n        MATCH (n:{escape_identifier(label)})\n        {where_str}\n        DETACH DELETE n\n        '
        tx.run(query_str, **params)

    @with_session.readwrite_transaction
    def delete_relationship_by_global_id(self, tx: ManagedTransaction, global_id: str) -> None:
        """
        globalId를 가진 관계를 찾아 삭제한다.
        """
        query: LiteralString = '\n        MATCH ()-[r {globalId: $gid}]-()\n        DELETE r\n        '
        tx.run(query, gid=global_id)

    @with_session.readwrite_transaction
    def delete_relationships_by_type(self, tx: ManagedTransaction, rel_type: str, property_filters: Optional[dict[str, Any]]=None) -> None:
        """
        특정 관계 타입과 속성 조건을 만족하는 관계들을 일괄 삭제한다.
        """
        where_clauses: list[LiteralString] = []
        params: dict[str, Any] = {}
        if property_filters:
            for idx, (k, v) in enumerate(property_filters.items()):
                param_key: LiteralString = cast(LiteralString, f'pf{idx}')
                where_clauses.append(f'r.{escape_identifier(k)} = ${param_key}')
                params[param_key] = v
        where_str: LiteralString = ''
        if where_clauses:
            where_str = 'WHERE ' + ' AND '.join(where_clauses)
        query_str: LiteralString = f'\n        MATCH ()-[r:{escape_identifier(rel_type)}]->()\n        {where_str}\n        DELETE r\n        '
        tx.run(query_str, **params)

    @with_session.readwrite_transaction
    def update_node_properties(self, tx: ManagedTransaction, global_id: str, new_properties: dict[str, Any]) -> None:
        """
        global_id 노드의 속성을 업데이트한다.
        존재하지 않는 속성은 새로 추가, 기존에 있으면 덮어쓴다.
        """
        query: LiteralString = '\n        MATCH (n {globalId: $gid})\n        SET n += $props\n        '
        tx.run(query, gid=global_id, props=new_properties)

    @with_session.readwrite_transaction
    def remove_node_property(self, tx: ManagedTransaction, global_id: str, property_key: str) -> None:
        """
        global_id 노드에서 특정 property 하나를 제거한다.
        """
        query: LiteralString = f'\n        MATCH (n {{globalId: $gid}})\n        SET n.{escape_identifier(property_key)} = null\n        '
        tx.run(query, gid=global_id)

    @with_session.readwrite_transaction
    def add_labels_to_node(self, tx: ManagedTransaction, global_id: str, labels: list[str]) -> None:
        """
        global_id 노드에 새로운 레이블들을 추가한다.
        예: SET n:LabelA:LabelB
        """
        if not labels:
            return
        label_clause: LiteralString = cast(LiteralString, 'SET n' + ''.join((f':{lbl}' for lbl in (escape_identifier(lb) for lb in labels))))
        query: LiteralString = f'\n        MATCH (n {{globalId: $gid}})\n        {label_clause}\n        '
        tx.run(query, gid=global_id)

    @with_session.readwrite_transaction
    def remove_labels_from_node(self, tx: ManagedTransaction, global_id: str, labels: list[str]) -> None:
        """
        global_id 노드에서 특정 레이블들을 제거한다.
        예: REMOVE n:LabelA:LabelB
        """
        if not labels:
            return
        remove_clause: LiteralString = cast(LiteralString, 'REMOVE n' + ''.join((f':{lbl}' for lbl in (escape_identifier(lb) for lb in labels))))
        query: LiteralString = f'\n        MATCH (n {{globalId: $gid}})\n        {remove_clause}\n        '
        tx.run(query, gid=global_id)

    @with_session.readwrite_transaction
    def update_relationship_properties(self, tx: ManagedTransaction, global_id: str, new_properties: dict[str, Any]) -> None:
        """
        global_id 관계의 속성을 업데이트한다.
        """
        query: LiteralString = '\n        MATCH ()-[r {globalId: $gid}]->()\n        SET r += $props\n        '
        tx.run(query, gid=global_id, props=new_properties)

    @with_session.readwrite_transaction
    def link_nodes(self, tx: ManagedTransaction, start_node_global_id: str, end_node_global_id: str, rel_type: str, properties: Optional[dict[str, Any]]=None) -> None:
        """
        start_node_global_id와 end_node_global_id를 가진 노드를
        주어진 관계(rel_type)로 연결한다. 없으면 생성, 있으면 업데이트.
        """
        query: LiteralString = f'\n        MATCH (start {{globalId: $startGid}})\n        MATCH (end {{globalId: $endGid}})\n        MERGE (start)-[r:{escape_identifier(rel_type)}]->(end)\n        SET r += $props\n        '
        tx.run(query, startGid=start_node_global_id, endGid=end_node_global_id, props=properties or {})

    @with_session.readonly_transaction
    def get_node_properties(self, tx: ManagedTransaction, global_id: str) -> Optional[dict[str, Any]]:
        """
        global_id 노드의 모든 속성을 Python dict 형태로 반환한다.
        """
        query: LiteralString = '\n        MATCH (n {globalId: $gid})\n        RETURN n\n        '
        rec = tx.run(query, gid=global_id).single()
        if rec is None:
            return None
        n = rec['n']
        node_obj = Node.from_neo4j(n)
        return {k: ensure_python_type(v) for k, v in node_obj.properties.items()}

    @with_session.readonly_transaction
    def get_relationship_properties(self, tx: ManagedTransaction, global_id: str) -> Optional[dict[str, Any]]:
        """
        global_id 관계의 모든 속성을 Python dict 형태로 반환한다.
        """
        query: LiteralString = '\n        MATCH ()-[r {globalId: $gid}]->()\n        RETURN r\n        '
        rec = tx.run(query, gid=global_id).single()
        if rec is None:
            return None
        r = rec['r']
        rel_obj = Relationship.from_neo4j(r)
        return {k: ensure_python_type(v) for k, v in rel_obj.properties.items()}

    @with_session.readonly_transaction
    def count_nodes(self, tx: ManagedTransaction, label: str) -> int:
        """
        특정 레이블을 가진 노드의 총 개수를 반환한다.
        """
        query: LiteralString = f'\n        MATCH (n:{escape_identifier(label)})\n        RETURN count(n) as cnt\n        '
        record = tx.run(cast(LiteralString, query)).single()
        return record['cnt'] if record else 0

    @with_session.readonly_transaction
    def count_relationships(self, tx: ManagedTransaction, rel_type: str) -> int:
        """
        특정 관계 타입을 가진 관계의 총 개수를 반환한다.
        """
        query: LiteralString = f'\n        MATCH ()-[r:{escape_identifier(rel_type)}]->()\n        RETURN count(r) as cnt\n        '
        record = tx.run(cast(LiteralString, query)).single()
        return record['cnt'] if record else 0

    @with_async_session.readonly_transaction
    async def afind_node_by_global_id(self, tx: AsyncManagedTransaction, global_id: str) -> Optional[Node]:
        """
        주어진 global_id를 가진 노드를 조회 (비동기)
        """
        query: LiteralString = '\n        MATCH (n {globalId: $globalId})\n        RETURN n\n        '
        result = await tx.run(query, globalId=global_id)
        record = await result.single()
        if record is None:
            return None
        return Node.from_neo4j(record['n'])

    @with_async_session.readonly_transaction
    async def amatch_nodes(self, tx: AsyncManagedTransaction, label: str, property_filters: Optional[dict[str, Any]]=None, limit: Optional[int]=None) -> list[Node]:
        """
        특정 레이블과 속성 조건으로 노드 목록을 조회 (비동기)
        """
        where_clauses: list[LiteralString] = []
        params: dict[LiteralString, Any] = {}
        if property_filters:
            for idx, (k, v) in enumerate(property_filters.items()):
                param_key: LiteralString = cast(LiteralString, f'p{idx}')
                where_clauses.append(f'n.{escape_identifier(k)} = ${param_key}')
                params[param_key] = v
        where_str: LiteralString = ''
        if where_clauses:
            where_str = 'WHERE ' + ' AND '.join(where_clauses)
        limit_clause: LiteralString = ''
        if limit is not None:
            limit_clause = cast(LiteralString, f'LIMIT {limit}')
        query_str: LiteralString = f'\n        MATCH (n:{escape_identifier(label)})\n        {where_str}\n        RETURN n\n        {limit_clause}\n        '
        result = await tx.run(query_str, **params)
        records: list[neo4j.Record] = []
        async for rec in result:
            records.append(rec)
        nodes: list[Node] = []
        for record in records:
            neo4j_node = record['n']
            nodes.append(Node.from_neo4j(neo4j_node))
        return nodes

    @with_async_session.readonly_transaction
    async def amatch_relationships(self, tx: AsyncManagedTransaction, rel_type: str, property_filters: Optional[dict[str, Any]]=None, limit: Optional[int]=None) -> list[Relationship]:
        """
        특정 relationship 타입과 속성 조건을 만족하는 관계 목록을 조회 (비동기)
        """
        where_clauses: list[LiteralString] = []
        params: dict[str, Any] = {}
        if property_filters:
            for idx, (k, v) in enumerate(property_filters.items()):
                param_key: LiteralString = cast(LiteralString, f'p{idx}')
                where_clauses.append(f'r.{escape_identifier(k)} = ${param_key}')
                params[param_key] = v
        where_str: LiteralString = ''
        if where_clauses:
            where_str = 'WHERE ' + ' AND '.join(where_clauses)
        limit_clause: LiteralString = ''
        if limit is not None:
            limit_clause = cast(LiteralString, f'LIMIT {limit}')
        query_str: LiteralString = f'\n        MATCH ()-[r:{escape_identifier(rel_type)}]->()\n        {where_str}\n        RETURN r\n        {limit_clause}\n        '
        result = await tx.run(cast(LiteralString, query_str), **params)
        records: list[neo4j.Record] = []
        async for rec in result:
            records.append(rec)
        rels: list[Relationship] = []
        for record in records:
            rels.append(Relationship.from_neo4j(record['r']))
        return rels

    @with_async_session.readwrite_transaction
    async def adelete_node_by_global_id(self, tx: AsyncManagedTransaction, global_id: str) -> None:
        """
        global_id를 가진 노드를 (관계까지) 삭제 (비동기)
        """
        query: LiteralString = '\n        MATCH (n {globalId: $gid})\n        DETACH DELETE n\n        '
        await tx.run(query, gid=global_id)

    @with_async_session.readwrite_transaction
    async def adelete_relationship_by_global_id(self, tx: AsyncManagedTransaction, global_id: str) -> None:
        """
        globalId를 가진 관계를 찾아 삭제 (비동기)
        """
        query: LiteralString = '\n        MATCH ()-[r {globalId: $gid}]-()\n        DELETE r\n        '
        await tx.run(query, gid=global_id)

    @with_async_session.readwrite_transaction
    async def aupdate_node_properties(self, tx: AsyncManagedTransaction, global_id: str, new_properties: dict[str, Any]) -> None:
        """
        global_id 노드의 속성을 업데이트한다. (비동기)
        """
        query: LiteralString = '\n        MATCH (n {globalId: $gid})\n        SET n += $props\n        '
        await tx.run(query, gid=global_id, props=new_properties)

    @with_async_session.readwrite_transaction
    async def aupdate_relationship_properties(self, tx: AsyncManagedTransaction, global_id: str, new_properties: dict[str, Any]) -> None:
        """
        global_id 관계의 속성을 업데이트 (비동기)
        """
        query: LiteralString = '\n        MATCH ()-[r {globalId: $gid}]->()\n        SET r += $props\n        '
        await tx.run(query, gid=global_id, props=new_properties)

    @with_async_session.readwrite_transaction
    async def alink_nodes(self, tx: AsyncManagedTransaction, start_node_global_id: str, end_node_global_id: str, rel_type: str, properties: Optional[dict[str, Any]]=None) -> None:
        """
        비동기 버전: 두 노드를 rel_type으로 연결한다. 없으면 생성, 있으면 업데이트.
        """
        query: LiteralString = f'\n        MATCH (start {{globalId: $startGid}})\n        MATCH (end {{globalId: $endGid}})\n        MERGE (start)-[r:{escape_identifier(rel_type)}]->(end)\n        SET r += $props\n        '
        await tx.run(query, startGid=start_node_global_id, endGid=end_node_global_id, props=properties or {})

    @with_async_session.readonly_transaction
    async def acount_nodes(self, tx: AsyncManagedTransaction, label: str) -> int:
        """
        특정 레이블을 가진 노드 총 개수 (비동기)
        """
        query: LiteralString = f'\n        MATCH (n:{escape_identifier(label)})\n        RETURN count(n) as cnt\n        '
        result = await tx.run(query)
        record = await result.single()
        if record is None:
            return 0
        return record['cnt']

    @with_async_session.readonly_transaction
    async def acount_relationships(self, tx: AsyncManagedTransaction, rel_type: str) -> int:
        """
        특정 관계 타입을 가진 관계 총 개수 (비동기)
        """
        query: LiteralString = f'\n        MATCH ()-[r:{escape_identifier(rel_type)}]->()\n        RETURN count(r) as cnt\n        '
        result = await tx.run(query)
        record = await result.single()
        if record is None:
            return 0
        return record['cnt']

==========

### neo4j_extension\bolt\__init__.py
from .connection import AsyncDriverKwargs, DriverKwargs, Neo4jConnection, SessionKwargs, with_async_session, with_session
__all__ = ['Neo4jConnection', 'with_session', 'with_async_session', 'DriverKwargs', 'AsyncDriverKwargs', 'SessionKwargs']

==========

### neo4j_extension\graph\pydantic_action.py
from copy import deepcopy
import logging
from collections import defaultdict
from typing import Generic, Literal, Optional, Self, TypeAlias, TypeVar, Union, get_args
from pydantic import BaseModel, model_validator
from .pydantic_model import GraphModel, NodeModel, PropertyModel, PropertyType, RelationshipModel
logger = logging.getLogger(__name__)
ActionTypes: TypeAlias = Literal['AddNode', 'RemoveNode', 'AddRelationship', 'RemoveRelationship', 'AddProperty', 'UpdateProperty', 'RemoveProperty', 'UpdateNodeLabels', 'UpdateRelationshipType']
GraphAction = Union['AddNodeAction', 'RemoveNodeAction', 'AddRelationshipAction', 'RemoveRelationshipAction', 'AddPropertyAction', 'UpdatePropertyAction', 'RemovePropertyAction', 'UpdateNodeLabelsAction']
A = TypeVar('A', bound=ActionTypes)

class GraphActionBase(BaseModel, Generic[A]):
    type: A

    @model_validator(mode='before')
    def default_type(cls, values: Union[Self, dict]):
        try:
            type, = get_args(cls.__pydantic_fields__['type'].annotation)
            if isinstance(values, dict):
                values['type'] = type
            if isinstance(values, GraphActionBase):
                values.type = type
            return values
        except Exception as e:
            logger.error(f'[{cls.__class__}] Failed to set default type: {e}')

class AddNodeAction(GraphActionBase[Literal['AddNode']]):
    nodes: list[NodeModel]

class AddRelationshipAction(GraphActionBase[Literal['AddRelationship']]):
    relationships: list[RelationshipModel]

class AddPropertyAction(GraphActionBase[Literal['AddProperty']]):
    entityId: int
    property: PropertyModel

class RemoveNodeAction(GraphActionBase[Literal['RemoveNode']]):
    nodeIds: list[int]

class RemoveRelationshipAction(GraphActionBase[Literal['RemoveRelationship']]):
    relationshipIds: list[int]

class RemovePropertyAction(GraphActionBase[Literal['RemoveProperty']]):
    entityId: int
    propertyKey: str

class UpdateNodeLabelsAction(GraphActionBase[Literal['UpdateNodeLabels']]):
    nodeId: int
    newLabels: list[str]

class UpdateRelationshipTypeAction(GraphActionBase[Literal['UpdateRelationshipType']]):
    relationshipId: int
    newType: str

class UpdatePropertyAction(GraphActionBase[Literal['UpdateProperty']]):
    entityId: int
    propertyKey: str
    newValue: PropertyType

def apply_actions(graph: GraphModel, actions: list[GraphAction]) -> GraphModel:
    graph_nodes: dict[int, NodeModel] = {node.uniqueId: deepcopy(node) for node in graph.nodes}
    graph_relationships: dict[int, RelationshipModel] = {rel.uniqueId: deepcopy(rel) for rel in graph.relationships}
    for action in actions:
        if isinstance(action, AddNodeAction):
            _ns: defaultdict[int, list[NodeModel]] = defaultdict(list)
            for _n in action.nodes:
                _existing_node: Optional[NodeModel] = graph_nodes.get(_n.uniqueId)
                if _existing_node is not None:
                    _ns[_n.uniqueId].append(_existing_node)
                _ns[_n.uniqueId].append(_n)
            for _nid, _rl in _ns.items():
                if not _rl:
                    continue
                if len(_rl) > 1:
                    logger.warning(f'AddNodeAction: Node {_nid} added multiple times. Only the last one will be kept.')
                graph_nodes[_nid] = NodeModel.merge_with_id(entities=_rl, uniqueId=_nid)
        elif isinstance(action, AddRelationshipAction):
            _rs: defaultdict[int, list[RelationshipModel]] = defaultdict(list)
            for _r in action.relationships:
                _existing_rel: Optional[RelationshipModel] = graph_relationships.get(_r.uniqueId)
                if _existing_rel is not None:
                    _rs[_r.uniqueId].append(_existing_rel)
                _rs[_r.uniqueId].append(_r)
            for _rid, _rl in _rs.items():
                if not _rl:
                    continue
                if len(_rl) > 1:
                    logger.warning(f'AddRelationshipAction: Relationship {_rid} added multiple times. Only the last one will be kept.')
                graph_relationships[_rid] = RelationshipModel.merge_with_id(entities=_rl, uniqueId=_rid)
        elif isinstance(action, AddPropertyAction):
            _eid = action.entityId
            _p = action.property
            if _eid in graph_nodes:
                _n = graph_nodes[_eid]
                if _eid in graph_relationships:
                    logger.warning(f'AddPropertyAction: Both node {_eid} and relationship {_eid} found. Node will be used.')
                _existing_p = next((p for p in _n.properties if p.k == _p.k), None)
                if _existing_p is not None:
                    logger.warning(f'AddPropertyAction: Property {_existing_p.k} already exists in node {_eid}. Overwriting.')
                    _n.properties.remove(_existing_p)
                    continue
                _n.properties.append(_p)
            elif _eid in graph_relationships:
                _r = graph_relationships[_eid]
                _existing_p = next((p for p in _r.properties if p.k == _p.k), None)
                if _existing_p is not None:
                    logger.warning(f'AddPropertyAction: Property {_existing_p.k} already exists in relationship {_eid}. Overwriting.')
                    _r.properties.remove(_existing_p)
                    continue
                _r.properties.append(_p)
            else:
                logger.warning(f'AddPropertyAction: Entity {_eid} not found. Skip.')
        elif isinstance(action, RemoveNodeAction):
            for _nid in action.nodeIds:
                if _nid in graph_nodes:
                    del graph_nodes[_nid]
                else:
                    logger.warning(f'RemoveNodeAction: node {_nid} not found. Skip.')
        elif isinstance(action, RemoveRelationshipAction):
            for _rid in action.relationshipIds:
                if _rid in graph_relationships:
                    del graph_relationships[_rid]
                else:
                    logger.warning(f'RemoveRelationshipAction: relationship {_rid} not found. Skip.')
        elif isinstance(action, RemovePropertyAction):
            _eid = action.entityId
            _pk = action.propertyKey
            if _eid in graph_nodes:
                _n = graph_nodes[_eid]
                if _eid in graph_relationships:
                    logger.warning(f'RemovePropertyAction: Both node {_eid} and relationship {_eid} found. Node will be used.')
                _existing_p = next((p for p in _n.properties if p.k == _pk), None)
                if _existing_p is not None:
                    _n.properties.remove(_existing_p)
                else:
                    logger.warning(f'RemovePropertyAction: Property {_pk} not found in node {_eid}. Skip.')
            elif _eid in graph_relationships:
                _r = graph_relationships[_eid]
                _existing_p = next((p for p in _r.properties if p.k == _pk), None)
                if _existing_p is not None:
                    _r.properties.remove(_existing_p)
                else:
                    logger.warning(f'RemovePropertyAction: Property {_pk} not found in relationship {_eid}. Skip.')
            else:
                logger.warning(f'RemovePropertyAction: Entity {_eid} not found. Skip.')
        elif isinstance(action, UpdateNodeLabelsAction):
            _nid = action.nodeId
            _n = graph_nodes.get(_nid)
            if _n is None:
                logger.warning(f'UpdateNodeLabelsAction: node {_nid} not found. Skip.')
                continue
            _n.labels = action.newLabels
        elif isinstance(action, UpdateRelationshipTypeAction):
            _rid = action.relationshipId
            _r = graph_relationships.get(_rid)
            if _r is None:
                logger.warning(f'UpdateRelationshipTypeAction: relationship {_rid} not found. Skip.')
                continue
            _r.type = action.newType
        elif isinstance(action, UpdatePropertyAction):
            _eid = action.entityId
            _pk = action.propertyKey
            _nv = action.newValue
            if _eid in graph_nodes:
                _n = graph_nodes[_eid]
                if _eid in graph_relationships:
                    logger.warning(f'UpdatePropertyAction: Both node {_eid} and relationship {_eid} found. Node will be used.')
                _existing_p = next((p for p in _n.properties if p.k == _pk), None)
                if _existing_p is not None:
                    _existing_p.v = _nv
                else:
                    logger.warning(f'UpdatePropertyAction: Property {_pk} not found in node {_eid}. Creating new property.')
                    _n.properties.append(PropertyModel(k=_pk, v=_nv))
            elif _eid in graph_relationships:
                _r = graph_relationships[_eid]
                _existing_p = next((p for p in _r.properties if p.k == _pk), None)
                if _existing_p is not None:
                    _existing_p.v = _nv
                else:
                    logger.warning(f'UpdatePropertyAction: Property {_pk} not found in relationship {_eid}. Creating new property.')
                    _r.properties.append(PropertyModel(k=_pk, v=_nv))
            else:
                logger.warning(f'UpdatePropertyAction: Entity {_eid} not found. Skip.')
    return GraphModel(nodes=list(graph_nodes.values()), relationships=list(graph_relationships.values()))

==========

### neo4j_extension\graph\pydantic_model.py
from __future__ import annotations
from abc import ABC, abstractmethod
from collections import defaultdict
from copy import deepcopy
from typing import Optional, Sequence, Type, TypeVar, cast
from uuid import uuid4
import neo4j
from pydantic import BaseModel, Field
from neo4j_extension.utils import generate_new_id
from ..types._utils import PythonType, ensure_python_type
from .structure import Graph, Node, Relationship
E = TypeVar('E', bound='EntityModel')
type PropertyType = int | float | str | bool | None | list[PropertyType]

class PropertyModel(BaseModel):
    """
    Represents a single key-value property for a node or relationship.
    """
    k: str
    v: PropertyType

class EntityModel(BaseModel, ABC):
    """
    Common fields for nodes and relationships.
    """
    properties: list[PropertyModel] = Field(default_factory=list, description='MUST include ALL key-value properties for this entity from the document.')
    uniqueId: int = Field(description='A unique ID for the entity.')

    @abstractmethod
    def to_neo4j(self, *args, **kwargs) -> neo4j.Entity:
        ...

    @property
    def python_props(self) -> dict[str, PythonType]:
        return {prop.k: ensure_python_type(cast(PythonType, prop.v)) for prop in self.properties}

    @property
    def json_props(self) -> dict[str, PropertyType]:
        return {prop.k: prop.v for prop in self.properties}

    @abstractmethod
    def __add__(self: E, other: E) -> E:
        ...

    @classmethod
    def merge_properties(cls: Type[E], entities: Sequence[E]) -> E:
        if not entities:
            raise ValueError('No entities to merge.')
        entity: EntityModel = deepcopy(entities[0])
        props: dict[str, PropertyModel] = {p.k: p for e in entities for p in e.properties}
        entity.properties.clear()
        entity.properties.extend(props.values())
        return entity

    @classmethod
    def merge_with_id(cls: Type[E], entities: Sequence[E], uniqueId: int) -> E:
        if not entities:
            raise ValueError('No entities to merge.')
        e = entities[0]
        for entity in entities[1:]:
            e += entity
        e.uniqueId = uniqueId
        return e

class NodeModel(EntityModel):
    """
    A single node in the graph.
    """
    labels: list[str] = Field(description='Labels that categorize this node (e.g., ["Animal"], ["Dog"], ["Animal", "Dog"]).')

    def to_neo4j(self, prefix: str) -> Node:
        return Node(properties=self.python_props, labels=set(self.labels), globalId=f'{prefix}#{self.uniqueId}')

    @property
    def signature(self) -> str:
        labels_key: str = '_'.join(sorted(self.labels))
        name_val = str(self.json_props.get('name', ''))
        return f'{labels_key}::{name_val}'

    def __add__(self, other: NodeModel) -> NodeModel:
        merged = NodeModel.merge_properties([self, other])
        merged.labels = list(set(self.labels + other.labels))
        return merged

    def orphan_find_original_node_index(self, nodes: list[NodeModel]) -> Optional[int]:
        """
        Given a candidate node, find its original index in 'nodes' by matching uniqueId.
        Return None if not found.
        """
        for i, n in enumerate(nodes):
            if n.uniqueId == self.uniqueId:
                return i
        else:
            return None

    def orphan_find_by_property_similarity(self, candidates: list[NodeModel]) -> Optional[NodeModel]:
        if not candidates:
            return None
        PROPERTY_WEIGHTS = {'name': 3.0, 'id': 2.5, 'identifier': 2.5, 'title': 2.0, 'type': 1.5}

        def similarity(a: PropertyType, b: PropertyType) -> float:
            if a is None or b is None:
                return 0.0
            if isinstance(a, str) and isinstance(b, str):
                a_s, b_s = (a.lower().strip(), b.lower().strip())
                if a_s == b_s:
                    return 1.0
                max_len = max(len(a_s), len(b_s))
                return 1.0 - abs(len(a_s) - len(b_s)) / max_len
            return 1.0 if a == b else 0.0
        orphan_props = self.json_props
        scores = []
        for candidate in candidates:
            candidate_props = candidate.json_props
            total_score = 0.0
            for key, weight in PROPERTY_WEIGHTS.items():
                ov = orphan_props.get(key)
                cv = candidate_props.get(key)
                if ov is not None and cv is not None:
                    total_score += weight * similarity(ov, cv)
            scores.append((total_score, candidate))
        max_score = max((s for s, _ in scores), default=0.0)
        top_candidates = [c for s, c in scores if s == max_score]
        return top_candidates[0] if top_candidates else None

    def orphan_find_by_label_match(self, candidates: list[NodeModel]) -> Optional[NodeModel]:
        if not candidates:
            return None
        label_scores = []
        orphan_labels = set(self.labels)
        for candidate in candidates:
            candidate_labels = set(candidate.labels)
            score = len(orphan_labels & candidate_labels)
            label_scores.append((score, candidate))
        if not label_scores:
            return None
        max_score = max((s for s, _ in label_scores))
        top_candidates = [c for s, c in label_scores if s == max_score]
        if len(top_candidates) > 1:
            return self.orphan_find_by_property_similarity(top_candidates)
        return top_candidates[0] if top_candidates else None

class RelationshipModel(EntityModel):
    """
    A single relationship (edge) in the graph.
    """
    type: str = Field(description='The type of this relationship.')
    startNode: NodeModel = Field(description='The start node for this relationship.')
    endNode: NodeModel = Field(description='The end node for this relationship.')

    def to_neo4j(self, node_map: dict[str, Node], prefix: str) -> Relationship:
        start_neo4j_node = node_map[f'{prefix}#{self.startNode.uniqueId}']
        end_neo4j_node = node_map[f'{prefix}#{self.endNode.uniqueId}']
        return Relationship(properties=self.python_props, rel_type=self.type, start_node=start_neo4j_node, end_node=end_neo4j_node, globalId=f'{prefix}#{self.uniqueId}')

    def __add__(self, other: RelationshipModel) -> RelationshipModel:
        merged = RelationshipModel.merge_properties([self, other])
        merged.type = other.type
        return merged

class GraphModel(BaseModel):
    """
    Contains a collection of nodes and relationships.
    """
    nodes: list[NodeModel] = Field(description='List of all nodes in the graph.')
    relationships: list[RelationshipModel] = Field(description='List of all relationships (edges) in the graph.')

    def to_neo4j(self) -> Graph:
        g = Graph()
        node_map: dict[str, Node] = {}
        prefix = uuid4().hex
        for node in self.nodes:
            node.uniqueId = int(node.uniqueId)
        for rel in self.relationships:
            rel.uniqueId = int(rel.uniqueId)
        for node_model in self.nodes:
            node_obj = node_model.to_neo4j(prefix=prefix)
            g.add_node(node_obj)
            node_map[f'{prefix}#{node_model.uniqueId}'] = node_obj
        for rel_model in self.relationships:
            rel_obj = rel_model.to_neo4j(node_map=node_map, prefix=prefix)
            g.add_relationship(rel_obj)
        return g

    @property
    def entities(self) -> list[EntityModel]:
        return list(self.nodes + self.relationships)

    def model_post_init(self, __context: dict) -> None:
        """
        After parsing this model, fix any ID conflicts (merge id duplicates).
        """
        node_ids: set[int] = {n.uniqueId for n in self.nodes}
        self.relationships = [r for r in self.relationships if r.startNode.uniqueId in node_ids and r.endNode.uniqueId in node_ids]
        id_to_model: defaultdict[int, list[EntityModel]] = defaultdict(list)
        for entity in self.entities:
            id_to_model[entity.uniqueId].append(entity)
        reserved_ids: set[int] = {id for id in id_to_model}
        nodes: list[NodeModel] = []
        relationships: list[RelationshipModel] = []
        for id, elist in id_to_model.items():
            if not elist:
                continue
            nlist: list[NodeModel] = []
            rlist: list[RelationshipModel] = []
            for e in elist:
                if isinstance(e, NodeModel):
                    nlist.append(e)
                elif isinstance(e, RelationshipModel):
                    rlist.append(e)
            if nlist:
                n: Optional[NodeModel] = NodeModel.merge_with_id(entities=nlist, uniqueId=id)
            else:
                n = None
            if rlist:
                r: Optional[RelationshipModel] = RelationshipModel.merge_with_id(entities=rlist, uniqueId=id)
            else:
                r = None
            if n is None:
                if r is None:
                    continue
                else:
                    relationships.append(r)
            elif r is None:
                nodes.append(n)
            else:
                nodes.append(n)
                new_id: int = generate_new_id(reserved_ids)
                r.uniqueId = new_id
                reserved_ids.add(new_id)
                relationships.append(r)
        self.nodes = nodes
        self.relationships = relationships

    def add_relationships(self, rels_to_add: list[RelationshipModel]) -> GraphModel:
        new_relationships = list(self.relationships)
        new_relationships.extend(rels_to_add)
        return GraphModel(nodes=self.nodes, relationships=new_relationships)

    def orphan_find_orphan_node_ids(self, components: list[list[int]]) -> list[int]:
        if len(components) <= 1:
            return []
        main_comp: list[int] = max(components, key=len)
        orphans: list[int] = []
        for comp in components:
            if comp is not main_comp:
                for idx in comp:
                    orphans.append(self.nodes[idx].uniqueId)
        return orphans

    def orphan_find_by_graph_topology(self, candidates: list[NodeModel]) -> Optional[NodeModel]:
        if not candidates:
            return None
        degree_centrality = defaultdict(int)
        for rel in self.relationships:
            degree_centrality[rel.startNode.uniqueId] += 1
            degree_centrality[rel.endNode.uniqueId] += 1
        scores: list[tuple[int, NodeModel]] = sorted([(degree_centrality[candidate.uniqueId], candidate) for candidate in candidates], key=lambda x: x[0])
        if not scores:
            return None
        highest_score, highest_score_node = scores[-1]
        return highest_score_node

    def orphan_find_central_node(self, nodes: list[NodeModel]) -> NodeModel:
        """
        Return the 'central' node in the subgraph by highest connectivity.
        If none found, fallback to the first node.
        """
        if not nodes:
            raise ValueError('No nodes given to _find_central_node')
        node_ids_in_main: set[int] = {n.uniqueId for n in nodes}
        connection_counts = defaultdict(int)
        for rel in self.relationships:
            if rel.startNode.uniqueId in node_ids_in_main:
                connection_counts[rel.startNode.uniqueId] += 1
            if rel.endNode.uniqueId in node_ids_in_main:
                connection_counts[rel.endNode.uniqueId] += 1
        if not connection_counts:
            return nodes[0]
        max_node_id = max(connection_counts, key=lambda k: connection_counts[k])
        return next((n for n in nodes if n.uniqueId == max_node_id))

    def orphan_validate_relationships(self, rels_to_add: list[RelationshipModel]) -> bool:
        existing = set(((r.startNode.uniqueId, r.endNode.uniqueId, r.type) for r in self.relationships))
        for r in rels_to_add:
            triple: tuple[int, int, str] = (r.startNode.uniqueId, r.endNode.uniqueId, r.type)
            if triple in existing:
                return False
        return True

    def orphan_infer_relationship_type(self, source: NodeModel, target: NodeModel) -> str:
        type_counter: defaultdict[str, int] = defaultdict(int)
        for rel in self.relationships:
            type_counter[rel.type] += 1
        if type_counter:
            common_type: str = max(type_counter, key=lambda k: type_counter[k])
            return common_type
        source_labels = '_'.join(sorted(source.labels))
        target_labels = '_'.join(sorted(target.labels))
        return f'{source_labels}_TO_{target_labels}'

    def orphan_find_heuristic_connection(self, orphan_data: list[tuple[NodeModel, list[NodeModel]]], start_id: int, fallback_node: Optional[NodeModel]) -> list[RelationshipModel]:
        new_rels = []
        current_id = start_id
        for orphan, candidates in orphan_data:
            best_match = orphan.orphan_find_by_label_match(candidates)
            if not best_match:
                best_match = orphan.orphan_find_by_property_similarity(candidates)
            if not best_match:
                best_match = self.orphan_find_by_graph_topology(candidates)
            target_node = best_match or fallback_node
            if not target_node:
                continue
            rel_type = self.orphan_infer_relationship_type(orphan, target_node)
            new_rels.append(RelationshipModel(uniqueId=current_id, type=rel_type, startNode=orphan, endNode=target_node, properties=[]))
            current_id += 1
        return new_rels

    def orphan_build_adjacency(self) -> tuple[list[list[int]], dict[int, int]]:
        node_idx_map: dict[int, int] = {}
        for i, n in enumerate(self.nodes):
            node_idx_map[n.uniqueId] = i
        adjacency = [[] for _ in range(len(self.nodes))]
        for r in self.relationships:
            s_i = node_idx_map[r.startNode.uniqueId]
            e_i = node_idx_map[r.endNode.uniqueId]
            adjacency[s_i].append(e_i)
            adjacency[e_i].append(s_i)
        return (adjacency, node_idx_map)

    def merge_duplicate_nodes(self) -> GraphModel:
        """
        Merges nodes that share the same 'signature' (labels, name property, etc.).
        Updates relationships to refer to the merged node.
        """
        original_nodes: list[NodeModel] = self.nodes
        relationships: list[RelationshipModel] = self.relationships
        signatures: dict[str, list[int]] = {}
        for idx, node in enumerate(original_nodes):
            sig = node.signature
            signatures.setdefault(sig, []).append(idx)
        merge_map: dict[int, int] = {}
        new_nodes: list[NodeModel] = []
        for sig, indices in signatures.items():
            if len(indices) == 1:
                i = indices[0]
                merge_map[i] = len(new_nodes)
                new_nodes.append(original_nodes[i])
            else:
                base_node = original_nodes[indices[0]]
                for i in indices[1:]:
                    base_node = base_node + original_nodes[i]
                merged_idx = len(new_nodes)
                for i in indices:
                    merge_map[i] = merged_idx
                new_nodes.append(base_node)
        new_relationships: list[RelationshipModel] = []
        for rel in relationships:
            s_idx: Optional[int] = rel.startNode.orphan_find_original_node_index(original_nodes)
            if s_idx is None or s_idx not in merge_map:
                continue
            new_s: NodeModel = new_nodes[merge_map[s_idx]]
            e_idx: Optional[int] = rel.endNode.orphan_find_original_node_index(original_nodes)
            if e_idx is None or e_idx not in merge_map:
                continue
            new_e: NodeModel = new_nodes[merge_map[e_idx]]
            if new_s.uniqueId == new_e.uniqueId:
                continue
            new_relationships.append(RelationshipModel(uniqueId=rel.uniqueId, type=rel.type, properties=rel.properties, startNode=new_s, endNode=new_e))
        return GraphModel(nodes=new_nodes, relationships=new_relationships)

class OrphanConnectionProposal(BaseModel):
    """Contains proposed relationships for connecting orphan nodes."""
    relationships: list[RelationshipModel] = Field(description='Proposed relationships to connect orphan nodes.')

    def process_llm_response(self, next_id: int) -> list[RelationshipModel]:
        new_rels = []
        for rel in self.relationships:
            new_rel = RelationshipModel(uniqueId=next_id, type=rel.type, startNode=rel.startNode, endNode=rel.endNode, properties=rel.properties.copy())
            new_rels.append(new_rel)
            next_id += 1
        return new_rels

class OrphanNodesFoundException(Exception):
    """
    Raised when orphan nodes are detected and automatically proposed relationships
    fail validation.
    """

    def __init__(self, message: str, partial_graph: GraphModel, orphan_node_ids: list[int], proposed_relationships: list[RelationshipModel]):
        super().__init__(message)
        self.partial_graph = partial_graph
        self.orphan_node_ids = orphan_node_ids
        self.proposed_relationships = proposed_relationships

==========

### neo4j_extension\graph\structure.py
from __future__ import annotations
from abc import ABC, abstractmethod
from collections import defaultdict
from typing import Any, LiteralString, Mapping, Optional, Self, Union
import neo4j
import neo4j.graph
from ..types._abc import Neo4jType
from ..types._utils import PythonType, convert_neo4j_to_python, ensure_neo4j_type, ensure_python_type, get_neo4j_property_type_name
from ..types.primitive import Neo4jList
from ..typing import GraphSchema, Property, Triplet
from ..utils import escape_identifier

class Entity(ABC):
    properties: dict[str, Neo4jType]
    globalId: Optional[str]

    def __init__(self, properties: Mapping[str, Union[Neo4jType, PythonType]], globalId: Optional[str]=None) -> None:
        self.globalId = globalId
        self.properties = {k: ensure_neo4j_type(v) for k, v in properties.items()}

    def __getitem__(self, key: str) -> PythonType:
        return ensure_python_type(self.properties[key])

    def __setitem__(self, key: str, value: Union[Neo4jType, PythonType]) -> None:
        self.properties[key] = ensure_neo4j_type(value)

    def to_python_props(self) -> dict[str, PythonType]:
        """
        Convert properties to Python basic types(dict).
        """
        result: dict[str, PythonType] = {}
        for k, v in self.properties.items():
            result[k] = convert_neo4j_to_python(v)
        if self.globalId:
            result['globalId'] = self.globalId
        return result

    def to_cypher_props(self) -> LiteralString:
        pairs: list[LiteralString] = []
        for k, v in self.properties.items():
            if isinstance(v, Neo4jList):
                if not v.is_storable_as_property():
                    raise ValueError(f"Property '{k}' contains a non-storable ListValue.")
            pairs.append(f'{escape_identifier(k)}: {v.to_cypher()}')
        if not pairs:
            return '{}'
        return '{ ' + ', '.join(pairs) + ' }'

    @abstractmethod
    def to_cypher(self) -> LiteralString:
        ...

    @classmethod
    @abstractmethod
    def from_neo4j(cls, entity: neo4j.graph.Entity) -> Self:
        ...

    @property
    def id(self) -> str:
        return f'{self.globalId or self.__class__.__name__ + '_' + str(id(self))}'

    def __repr__(self) -> LiteralString:
        return self.to_cypher()

    @abstractmethod
    def __str__(self) -> str:
        ...

class Node(Entity):
    labels: frozenset[str]

    def __init__(self, properties: Mapping[str, Union[Neo4jType, PythonType]], labels: Optional[set[str] | frozenset[str]]=None, globalId: Optional[str]=None) -> None:
        super().__init__(properties=properties, globalId=globalId)
        self.labels = frozenset(labels or ())

    @classmethod
    def from_neo4j(cls, entity: neo4j.graph.Node) -> Self:
        properties: dict[str, Any] = entity._properties
        globalId = properties.get('globalId')
        if globalId:
            globalId = str(globalId)
        else:
            globalId = None
        return cls(properties=properties, labels=entity.labels, globalId=globalId)

    def __str__(self) -> str:
        return f'({self.labelstring}){self.to_python_props()}'

    def to_cypher(self) -> LiteralString:
        props: LiteralString = self.to_cypher_props()
        return f'({escape_identifier(self.id)}: {self.safe_labelstring} {props})'

    @property
    def labelstring(self) -> str:
        labels: str = ':'.join(sorted(self.labels))
        return labels or 'Node'

    @property
    def safe_labelstring(self) -> LiteralString:
        labels: LiteralString = ':'.join((escape_identifier(label) for label in sorted(self.labels)))
        return labels or 'Node'

class Relationship(Entity):
    rel_type: str
    start_node: Node
    end_node: Node

    def __init__(self, properties: Mapping[str, Union[Neo4jType, PythonType]], rel_type: str, start_node: Node, end_node: Node, globalId: Optional[str]=None) -> None:
        super().__init__(properties=properties, globalId=globalId)
        self.rel_type = rel_type
        self.start_node = start_node
        self.end_node = end_node

    def __str__(self) -> str:
        return f'[{self.start_node.id} {self.rel_type} {self.end_node.id}]{self.to_python_props()}'

    @classmethod
    def from_neo4j(cls, entity: neo4j.graph.Relationship) -> Self:
        if entity.start_node is None or entity.end_node is None:
            raise ValueError('Relationship must have both a start and end node.')
        properties: dict[str, Any] = entity._properties
        globalId = properties.get('globalId')
        if globalId:
            globalId = str(globalId)
        else:
            globalId = None
        return cls(properties=properties, rel_type=entity.type, start_node=Node.from_neo4j(entity.start_node), end_node=Node.from_neo4j(entity.end_node), globalId=globalId)

    def to_cypher(self) -> LiteralString:
        start_node: LiteralString = self.start_node.to_cypher()
        id: LiteralString = escape_identifier(self.id)
        rel_type: LiteralString = escape_identifier(self.rel_type)
        props_str: LiteralString = self.to_cypher_props()
        end_node: LiteralString = self.end_node.to_cypher()
        return f'{start_node}-[{id}: {rel_type} {props_str}]->{end_node}'

class Graph:

    def __init__(self, nodes: Optional[dict[str, Node]]=None, relationships: Optional[dict[str, Relationship]]=None) -> None:
        self.nodes: dict[str, Node] = nodes or {}
        self.relationships: dict[str, Relationship] = relationships or {}

    def __repr__(self) -> str:
        if self.nodes:
            n = '\n' + '\n'.join(('- ' + str(n) for n in self.nodes.values())) + '\n'
        else:
            n = ''
        if self.relationships:
            r = '\n' + '\n'.join(('- ' + str(r) for r in self.relationships.values())) + '\n'
        else:
            r = ''
        return f'### Nodes {n}\n### Relationships{r}'

    @classmethod
    def from_neo4j(cls, graph: neo4j.graph.Graph) -> Graph:
        result = cls()
        for entity in graph.nodes:
            result.add_node(Node.from_neo4j(entity))
        for entity in graph.relationships:
            result.add_relationship(Relationship.from_neo4j(entity))
        return result

    def add_node(self, node: Node) -> None:
        self.nodes[node.id] = node

    def add_relationship(self, relationship: Relationship) -> None:
        self.relationships[relationship.id] = relationship

    def remove_node(self, node_id: str) -> None:
        to_remove: list[str] = []
        for rid, rel in self.relationships.items():
            if rel.start_node.id == node_id or rel.end_node.id == node_id:
                to_remove.append(rid)
        for rid in to_remove:
            self.remove_relationship(rid)
        self.nodes.pop(node_id, None)

    def remove_relationship(self, rel_id: str) -> None:
        self.relationships.pop(rel_id, None)

    def get_graph_schema(self) -> GraphSchema:
        """
        현재 in-memory Graph에 존재하는 Node/Relationship 정보를 기반으로
        간단한 스키마 정보를 구성해 GraphSchema(dict) 형태로 반환한다.
        """
        node_props_dict: defaultdict[str, set[tuple[str, str]]] = defaultdict(set)
        rel_props_dict: defaultdict[str, set] = defaultdict(set)
        relationships_list: list[Triplet] = []
        for node in self.nodes.values():
            labels: str = node.labelstring
            for prop_key, neo4j_val in node.properties.items():
                prop_type_name: str = get_neo4j_property_type_name(neo4j_val)
                node_props_dict[labels].add((prop_key, prop_type_name))
        for rel in self.relationships.values():
            for prop_key, neo4j_val in rel.properties.items():
                prop_type_name: str = get_neo4j_property_type_name(neo4j_val)
                rel_props_dict[rel.rel_type].add((prop_key, prop_type_name))
            relationships_list.append({'start': rel.start_node.safe_labelstring, 'type': rel.rel_type, 'end': rel.end_node.safe_labelstring})
        node_props: dict[str, list[Property]] = {}
        for label, propset in node_props_dict.items():
            node_props[label] = [{'property': prop_name, 'type': prop_type} for prop_name, prop_type in sorted(propset)]
        rel_props: dict[str, list[Property]] = {}
        for rtype, propset in rel_props_dict.items():
            rel_props[rtype] = [{'property': prop_name, 'type': prop_type} for prop_name, prop_type in sorted(propset)]
        graph_schema: GraphSchema = {'node_props': node_props, 'rel_props': rel_props, 'relationships': relationships_list, 'metadata': {'constraint': [], 'index': []}}
        return graph_schema

    def get_formatted_graph_schema(self) -> str:
        """
        현재 그래프의 스키마 정보를 사람이 읽기 좋은 형식의 문자열로 반환한다.
        (Neo4jConnection.format_graph_schema()와 유사 형식)
        """
        schema = self.get_graph_schema()
        lines: list[str] = []
        lines.append('### Node properties')
        node_props = schema.get('node_props', {})
        for label, props in node_props.items():
            lines.append(f'- {label}')
            for p in props:
                lines.append(f'  * {p['property']}: {p['type']}')
        lines.append('')
        lines.append('### Relationship properties')
        rel_props = schema.get('rel_props', {})
        for rtype, rprops in rel_props.items():
            lines.append(f'- {rtype}')
            for rp in rprops:
                lines.append(f'  * {rp['property']}: {rp['type']}')
        lines.append('')
        lines.append('### Relationships')
        rels = schema.get('relationships', [])
        for rel_dict in rels:
            lines.append(f'- (:{rel_dict['start']})-[:{rel_dict['type']}]->(:{rel_dict['end']})')
        return '\n'.join(lines)
if __name__ == '__main__':
    print(Node(properties={}).to_cypher())
    graph = Graph()
    node1 = Node({'name': 'Alice'}, {'Person'}, 'alice')
    node2 = Node({'name': 'Bob'}, {'Person'}, 'bob')
    rel = Relationship({'since': 1999}, 'KNOWS', node1, node2, 'alice_knows_bob')
    graph.add_node(node1)
    graph.add_node(node2)
    graph.add_relationship(rel)
    print(node1)
    print(node2)
    print(rel)
    print(graph.nodes)
    print(graph.relationships)
    graph.remove_node('alice')
    print(graph.nodes)
    print(graph.relationships)
    graph.remove_relationship('alice_knows_bob')
    print(graph.relationships)

==========

### neo4j_extension\graph\__init__.py
from .pydantic_action import AddNodeAction, AddPropertyAction, AddRelationshipAction, GraphAction, RemoveNodeAction, RemovePropertyAction, RemoveRelationshipAction, UpdateNodeLabelsAction, UpdatePropertyAction, UpdateRelationshipTypeAction, apply_actions
from .pydantic_model import EntityModel, GraphModel, NodeModel, OrphanConnectionProposal, OrphanNodesFoundException, PropertyModel, PropertyType, RelationshipModel
from .structure import Entity, Graph, Node, Relationship
__all__ = ['AddNodeAction', 'AddPropertyAction', 'AddRelationshipAction', 'apply_actions', 'Entity', 'EntityModel', 'Graph', 'GraphAction', 'GraphModel', 'Node', 'NodeModel', 'OrphanConnectionProposal', 'OrphanNodesFoundException', 'PropertyModel', 'PropertyType', 'Relationship', 'RemoveNodeAction', 'RemovePropertyAction', 'RemoveRelationshipAction', 'UpdateNodeLabelsAction', 'UpdatePropertyAction', 'UpdateRelationshipTypeAction', 'RelationshipModel']

==========

### neo4j_extension\types\primitive.py
from __future__ import annotations
import base64
import re
from typing import Dict as PyDict
from typing import List as PyList
from typing import LiteralString, cast
from ._abc import Neo4jType
from ..utils import split_by_comma_top_level, tokenize_cypher_expression
LIST_REGEX = re.compile('^\\s*\\[\\s*(.*)\\s*\\]\\s*$', re.DOTALL)
MAP_REGEX = re.compile('^\\s*\\{\\s*(.*)\\s*\\}\\s*$', re.DOTALL)

class Neo4jNull(Neo4jType[None]):
    """
    Neo4j 상의 null 값 표현. (v1의 NullValue에 해당)
    """
    value: None = None

    def to_cypher(self) -> LiteralString:
        return 'null'

    @classmethod
    def from_cypher(cls, cypher_str: str) -> Neo4jNull:
        if cypher_str.strip().lower() == 'null':
            return cls()
        raise ValueError(f'Not a valid null literal: {cypher_str}')

class Neo4jBoolean(Neo4jType[bool]):
    """
    Corresponds to Neo4j's BOOLEAN type (true / false).
    """

    def __init__(self, value: bool):
        self.value = bool(value)

    def to_cypher(self) -> LiteralString:
        return 'true' if self.value else 'false'

    @classmethod
    def from_cypher(cls, cypher_str: str) -> Neo4jBoolean:
        s = cypher_str.strip().lower()
        if s == 'true':
            return cls(True)
        elif s == 'false':
            return cls(False)
        raise ValueError(f'Invalid Neo4j boolean string: {cypher_str}')

class Neo4jInteger(Neo4jType[int]):
    """
    Corresponds to Neo4j's INTEGER type (64-bit signed).
    """

    def __init__(self, value: int):
        if value < -2 ** 63 or value > 2 ** 63 - 1:
            raise OverflowError('Neo4j INTEGER out of 64-bit range.')
        self.value = value

    def to_cypher(self) -> LiteralString:
        return cast(LiteralString, str(self.value))

    @classmethod
    def from_cypher(cls, cypher_str: str) -> Neo4jInteger:
        val = int(cypher_str.strip())
        return cls(val)

class Neo4jFloat(Neo4jType[float]):
    """
    Corresponds to Neo4j's FLOAT type (64-bit).
    """

    def __init__(self, value: float):
        self.value = float(value)

    def to_cypher(self) -> LiteralString:
        return cast(LiteralString, repr(self.value))

    @classmethod
    def from_cypher(cls, cypher_str: str) -> Neo4jFloat:
        s = cypher_str.strip().lower()
        if s == 'nan':
            return cls(float('nan'))
        elif s == 'infinity':
            return cls(float('inf'))
        elif s == '-infinity':
            return cls(float('-inf'))
        val = float(s)
        return cls(val)

class Neo4jString(Neo4jType[str]):
    """
    Corresponds to Neo4j's STRING type.
    """
    STRING_REGEX = re.compile("^\\s*'((?:\\\\.|''|[^'\\\\])*)'\\s*$", re.DOTALL)

    def __init__(self, value: str):
        self.value = value

    def to_cypher(self) -> LiteralString:
        escaped = self.value
        escaped = escaped.replace('\\', '\\\\')
        escaped = escaped.replace("'", "''")
        return cast(LiteralString, f"'{escaped}'")

    @classmethod
    def from_cypher(cls, cypher_str: str) -> Neo4jString:
        match = cls.STRING_REGEX.match(cypher_str)
        if not match:
            raise ValueError(f'Invalid Neo4j string literal: {cypher_str}')
        content = match.group(1)
        content = content.replace("''", "'")
        content = content.replace('\\n', '\n')
        content = content.replace('\\t', '\t')
        content = content.replace('\\r', '\r')
        content = content.replace('\\b', '\x08')
        content = content.replace('\\f', '\x0c')
        content = content.replace('\\\\', '\\')
        return cls(content)

class Neo4jByteArray(Neo4jType[bytes]):
    """
    Neo4j에 byte array를 넘길 수 있으나, Neo4j literal은 공식 문법이 없다.
    여기서는 'bytearray("...")' 식으로 가정하고 base64 인코딩/디코딩을 해본다.
    """

    def __init__(self, value: bytes):
        self.value = value

    def to_cypher(self) -> LiteralString:
        encoded = base64.b64encode(self.value).decode('ascii')
        return cast(LiteralString, f"bytearray('{encoded}')")

    @classmethod
    def from_cypher(cls, cypher_str: str) -> Neo4jByteArray:
        s = cypher_str.strip()
        m = re.match("^bytearray\\s*\\(\\s*'([^']*)'\\s*\\)$", s)
        if not m:
            raise ValueError(f'Invalid Neo4j bytearray literal: {cypher_str}')
        b64 = m.group(1)
        data = base64.b64decode(b64.encode('ascii'))
        return cls(data)

class Neo4jList(Neo4jType[PyList[Neo4jType]]):
    """
    Represents a Neo4j LIST type: [elem0, elem1, ...].
    """

    def __init__(self, value: PyList[Neo4jType]):
        """
        Auto-cast high-level types to lower-level types in the list. (e.g., Boolean->Integer->Float)

        - If there is at least one Float, all Boolean/Integer are converted to Float.
        - If there is no Float but Boolean/Integer, Boolean is converted to Integer.
        - Otherwise, keep as is if other types are mixed.
        """
        has_float: bool = any((isinstance(x, Neo4jFloat) for x in value))
        if has_float:
            self.value = [Neo4jFloat(_cast_to_float(x)) for x in value]
            return
        has_bool: bool = any((isinstance(x, Neo4jBoolean) for x in value))
        has_int: bool = any((isinstance(x, Neo4jInteger) for x in value))
        if (has_bool or has_int) and all((isinstance(x, (Neo4jBoolean, Neo4jInteger)) for x in value)):
            self.value = [Neo4jInteger(_cast_to_int(x)) for x in value]
            return
        self.value = value

    def to_cypher(self) -> LiteralString:
        return '[' + ', '.join((elem.to_cypher() for elem in self.value)) + ']'

    @classmethod
    def from_cypher(cls, cypher_str: str) -> Neo4jList:
        from ._utils import convert_cypher_to_neo4j
        m = LIST_REGEX.match(cypher_str)
        if not m:
            raise ValueError(f'Invalid Neo4j list literal: {cypher_str}')
        inner = m.group(1).strip()
        if not inner:
            return cls([])
        tokens = tokenize_cypher_expression(inner)
        elements_str_list = split_by_comma_top_level(tokens)
        parsed_elems = [convert_cypher_to_neo4j(elem_str) for elem_str in elements_str_list]
        return cls(parsed_elems)

    def is_storable_as_property(self) -> bool:
        """
        Neo4j에 property로 저장 가능한 리스트인지(동질 타입 + null 없음 + 중첩 불가 등) 검사.
        (v1의 ListValue.is_storable_as_property 참고)
        """
        from ._utils import get_neo4j_property_type_name
        if not self.value:
            return True
        type_list = []
        for val in self.value:
            tname = get_neo4j_property_type_name(val)
            if tname == 'null':
                return False
            if tname == 'list':
                return False
            type_list.append(tname)
        first = type_list[0]
        for other_type in type_list[1:]:
            if other_type != first:
                return False
        return True

def _cast_to_float(val: Neo4jType) -> float:
    if isinstance(val, Neo4jFloat):
        return val.value
    elif isinstance(val, Neo4jInteger):
        return float(val.value)
    elif isinstance(val, Neo4jBoolean):
        return 1.0 if val.value else 0.0
    raise TypeError(f'Cannot cast {type(val).__name__} to float')

def _cast_to_int(val: Neo4jType) -> int:
    if isinstance(val, Neo4jInteger):
        return val.value
    elif isinstance(val, Neo4jBoolean):
        return 1 if val.value else 0
    raise TypeError(f'Cannot cast {type(val).__name__} to int')

class Neo4jMap(Neo4jType[PyDict[str, Neo4jType]]):
    """
    Represents a Neo4j MAP: { key: value, ... }.
    """

    def __init__(self, value: PyDict[str, Neo4jType]):
        self.value = value

    def to_cypher(self) -> LiteralString:
        parts: PyList[LiteralString] = []
        for k, v in self.value.items():
            k_cypher = Neo4jString(k).to_cypher()
            v_cypher = v.to_cypher()
            parts.append(f'{k_cypher}: {v_cypher}')
        return '{' + ', '.join(parts) + '}'

    @classmethod
    def from_cypher(cls, cypher_str: str) -> Neo4jMap:
        from ._utils import convert_cypher_to_neo4j
        m = MAP_REGEX.match(cypher_str)
        if not m:
            raise ValueError(f'Invalid Neo4j map literal: {cypher_str}')
        inner = m.group(1).strip()
        if not inner:
            return cls({})
        tokens = tokenize_cypher_expression(inner)
        elements_str_list = split_by_comma_top_level(tokens)
        result: PyDict[str, Neo4jType] = {}
        for pair_str in elements_str_list:
            pair_tokens = tokenize_cypher_expression(pair_str)
            try:
                colon_index = pair_tokens.index(':')
            except ValueError:
                raise ValueError(f'Invalid map entry (no colon): {pair_str}')
            key_tokens = pair_tokens[:colon_index]
            val_tokens = pair_tokens[colon_index + 1:]
            key_str = ''.join(key_tokens).strip()
            if re.match('^[a-zA-Z_][a-zA-Z0-9_]*$', key_str):
                key = key_str
            else:
                key_val = Neo4jString.from_cypher(key_str)
                key = key_val.value
            val_str = ''.join(val_tokens).strip()
            val_obj = convert_cypher_to_neo4j(val_str)
            result[key] = val_obj
        return cls(result)

==========

### neo4j_extension\types\spatial.py
from __future__ import annotations
import json
import re
from typing import LiteralString, Optional, cast
from ._abc import Neo4jType
POINT_REGEX = re.compile('^\\s*point\\(\\s*(\\{.*\\})\\s*\\)\\s*$', re.IGNORECASE)

class PointValue:
    """
    Represents a POINT value in Neo4j, with CRS, X, Y, and optionally Z coordinates.
    """
    __slots__ = ('crs', 'x', 'y', 'z')

    def __init__(self, crs: LiteralString, x: float, y: float, z: Optional[float]=None):
        self.crs: LiteralString = crs
        self.x: float = x
        self.y: float = y
        self.z: float | None = z

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, PointValue):
            return False
        return self.crs == other.crs and self.x == other.x and (self.y == other.y) and (self.z == other.z)

    def __repr__(self) -> str:
        return f'PointValue(crs={self.crs!r}, x={self.x}, y={self.y}, z={self.z})'

class Neo4jPoint(Neo4jType[PointValue]):
    """
    Corresponds to Neo4j's POINT type.
    """

    def __init__(self, value: PointValue):
        self.value = value

    def to_cypher(self) -> LiteralString:
        parts: list[LiteralString] = [cast(LiteralString, f'x: {self.value.x}'), cast(LiteralString, f'y: {self.value.y}')]
        if self.value.z is not None:
            parts.append(cast(LiteralString, f'z: {self.value.z}'))
        parts.append(f"crs: '{self.value.crs}'")
        inner = '{ ' + ', '.join(parts) + ' }'
        return f'point({inner})'

    @classmethod
    def from_cypher(cls, cypher_str: str) -> Neo4jPoint:
        m = POINT_REGEX.match(cypher_str)
        if not m:
            raise ValueError(f'Invalid Neo4j point literal: {cypher_str}')
        map_str = m.group(1).strip()
        tmp = re.sub("'", '"', map_str)
        tmp = re.sub('(\\w+)\\s*:', '"\\1":', tmp)
        try:
            data = json.loads(tmp)
        except json.JSONDecodeError as e:
            raise ValueError(f'Invalid point map: {map_str}') from e
        if 'x' not in data or 'y' not in data:
            raise ValueError(f'Invalid point map, must contain x,y keys: {cypher_str}')
        crs = data.get('crs', 'cartesian')
        x = float(data['x'])
        y = float(data['y'])
        z = data['z'] if 'z' in data else None
        if z is not None:
            z = float(z)
        return cls(PointValue(crs=crs, x=x, y=y, z=z))

==========

### neo4j_extension\types\temporal.py
from __future__ import annotations
import re
from datetime import date, datetime, time, timedelta
from typing import LiteralString, Optional, cast
from ._abc import Neo4jType
DATE_REGEX = re.compile('^\\s*date\\(\\s*([\'"])([0-9+\\-]{1,}-[0-9]{1,2}-[0-9]{1,2})\\1\\s*\\)\\s*$', re.IGNORECASE)

class Neo4jDate(Neo4jType[date]):
    """
    Corresponds to Neo4j's DATE type: ISO-8601 date (YYYY-MM-DD).
    """

    def __init__(self, value: date):
        self.value = value

    def to_cypher(self) -> LiteralString:
        return cast(LiteralString, f"date('{self.value.isoformat()}')")

    @classmethod
    def from_cypher(cls, cypher_str: str) -> Neo4jDate:
        m = DATE_REGEX.match(cypher_str)
        if not m:
            raise ValueError(f'Invalid Neo4j date literal: {cypher_str}')
        iso_str = m.group(2)
        try:
            d = date.fromisoformat(iso_str)
        except ValueError as e:
            raise ValueError(f'Invalid date format: {iso_str}') from e
        return cls(d)
TIME_REGEX = re.compile('^\\s*time\\(\\s*([\'"])([0-9:\\.]+)\\1\\s*\\)\\s*$', re.IGNORECASE)

class Neo4jLocalTime(Neo4jType[time]):
    """
    Corresponds to Neo4j's LOCAL TIME type (no timezone).
    """

    def __init__(self, value: time):
        self.value = value

    def to_cypher(self) -> LiteralString:
        return cast(LiteralString, f"time('{self.value.isoformat()}')")

    @classmethod
    def from_cypher(cls, cypher_str: str) -> Neo4jLocalTime:
        m = TIME_REGEX.match(cypher_str)
        if not m:
            raise ValueError(f'Invalid Neo4j local time literal: {cypher_str}')
        iso_str = m.group(2)
        try:
            t = time.fromisoformat(iso_str)
        except ValueError as e:
            raise ValueError(f'Invalid local time format: {iso_str}') from e
        if t.tzinfo is not None:
            raise ValueError('Expected local time (no tzinfo).')
        return cls(t)
LOCAL_DATETIME_REGEX = re.compile('^\\s*datetime\\(\\s*([\'"])([0-9+\\-T:\\.]+)\\1\\s*\\)\\s*$', re.IGNORECASE)

class Neo4jLocalDateTime(Neo4jType[datetime]):
    """
    Corresponds to Neo4j's LOCAL DATETIME type (no timezone).
    """

    def __init__(self, value: datetime):
        if value.tzinfo is not None:
            raise ValueError('LocalDateTime should not have tzinfo.')
        self.value = value

    def to_cypher(self) -> LiteralString:
        return cast(LiteralString, f"datetime('{self.value.isoformat()}')")

    @classmethod
    def from_cypher(cls, cypher_str: str) -> Neo4jLocalDateTime:
        m = LOCAL_DATETIME_REGEX.match(cypher_str)
        if not m:
            raise ValueError(f'Invalid local datetime literal: {cypher_str}')
        iso_str = m.group(2)
        try:
            dt = datetime.fromisoformat(iso_str)
        except ValueError as e:
            raise ValueError(f'Invalid local datetime format: {iso_str}') from e
        if dt.tzinfo is not None:
            raise ValueError('Expected local datetime (no tz).')
        return cls(dt)
ZONED_TIME_REGEX = re.compile('^\\s*time\\(\\s*([\'"])([0-9:\\.\\+\\-]+)\\1\\s*\\)\\s*$', re.IGNORECASE)

class Neo4jZonedTime(Neo4jType[time]):
    """
    Corresponds to Neo4j's ZONED TIME type (time with timezone offset).
    """

    def __init__(self, value: time):
        if value.tzinfo is None:
            raise ValueError('ZonedTime requires a tzinfo (offset).')
        self.value = value

    def to_cypher(self) -> LiteralString:
        return cast(LiteralString, f"time('{self.value.isoformat()}')")

    @classmethod
    def from_cypher(cls, cypher_str: str) -> Neo4jZonedTime:
        m = ZONED_TIME_REGEX.match(cypher_str)
        if not m:
            raise ValueError(f'Invalid Neo4j zoned time literal: {cypher_str}')
        iso_str = m.group(2)
        try:
            t = time.fromisoformat(iso_str)
        except ValueError as e:
            raise ValueError(f'Invalid zoned time format: {iso_str}') from e
        if t.tzinfo is None:
            raise ValueError('Zoned time string must have offset.')
        return cls(t)
ZONED_DATETIME_REGEX = re.compile('^\\s*datetime\\(\\s*([\'"])([0-9+\\-T:\\.]+(?:Z|[+\\-][0-9:]+))\\1\\s*\\)\\s*$', re.IGNORECASE)

class Neo4jZonedDateTime(Neo4jType[datetime]):
    """
    Corresponds to Neo4j's ZONED DATETIME type (datetime with timezone offset).
    """

    def __init__(self, value: datetime):
        if value.tzinfo is None:
            raise ValueError('ZonedDateTime requires a tzinfo.')
        self.value = value

    def to_cypher(self) -> LiteralString:
        return cast(LiteralString, f"datetime('{self.value.isoformat()}')")

    @classmethod
    def from_cypher(cls, cypher_str: str) -> Neo4jZonedDateTime:
        m = ZONED_DATETIME_REGEX.match(cypher_str)
        if not m:
            raise ValueError(f'Invalid Neo4j zoned datetime literal: {cypher_str}')
        iso_str = m.group(2)
        try:
            dt = datetime.fromisoformat(iso_str)
        except ValueError as e:
            raise ValueError(f'Invalid zoned datetime format: {iso_str}') from e
        if dt.tzinfo is None:
            raise ValueError('Zoned datetime must have offset.')
        return cls(dt)
DURATION_REGEX = re.compile('^\\s*duration\\(\\s*([\'"])(P.*)\\1\\s*\\)\\s*$', re.IGNORECASE)
DURATION_ISO_REGEX = re.compile('\n    ^\n    P\n    (?:(?P<years>   [+-]?\\d+(?:\\.\\d+)? )Y)?\n    (?:(?P<months>  [+-]?\\d+(?:\\.\\d+)? )M)?\n    (?:(?P<days>    [+-]?\\d+(?:\\.\\d+)? )D)?\n    (?:T\n        (?:(?P<hours>   [+-]?\\d+(?:\\.\\d+)? )H)?\n        (?:(?P<minutes> [+-]?\\d+(?:\\.\\d+)? )M)?\n        (?:(?P<seconds> [+-]?\\d+(?:\\.\\d+)? )S)?\n    )?\n    $\n    ', re.IGNORECASE | re.VERBOSE)

class Neo4jDuration(Neo4jType[timedelta]):
    """
    Corresponds to Neo4j's DURATION type.
    """

    def __init__(self, value: timedelta):
        self.value = value

    def to_cypher(self) -> LiteralString:
        total_seconds = int(self.value.total_seconds())
        micros = self.value.microseconds
        sign = -1 if total_seconds < 0 else 1
        total_seconds = abs(total_seconds)
        days = total_seconds // 86400
        remain = total_seconds % 86400
        hours = remain // 3600
        remain %= 3600
        minutes = remain // 60
        seconds = remain % 60
        frac: str = ''
        if micros > 0:
            frac_val = micros / 1000000
            frac = f'{frac_val}'.lstrip('0')
        base: str = f'P{days}DT{hours}H{minutes}M{seconds}{frac}S'
        return cast(LiteralString, f"duration('{('-' if sign < 0 else '')}{base}')")

    @classmethod
    def from_cypher(cls, cypher_str: str) -> Neo4jDuration:
        s = cypher_str.strip()
        pattern = "^duration\\(\\s*'(?P<sign>[+-])?P(?:(?P<years>\\d+(?:\\.\\d+)?)Y)?(?:(?P<months>\\d+(?:\\.\\d+)?)M)?(?:(?P<weeks>\\d+(?:\\.\\d+)?)W)?(?:(?P<days>\\d+(?:\\.\\d+)?)D)?(?:T(?:(?P<hours>\\d+(?:\\.\\d+)?)H)?(?:(?P<minutes>\\d+(?:\\.\\d+)?)M)?(?:(?P<seconds>\\d+(?:\\.\\d+)?)S)?)?'\\s*\\)$"
        m = re.match(pattern, s)
        if not m:
            raise ValueError(f'[DurationValue] duration(...), Not a literal: {cypher_str}')

        def to_f(raw: Optional[str]) -> float:
            return float(raw) if raw else 0.0
        sign_str = m.group('sign')
        sign = -1 if sign_str == '-' else 1
        years = to_f(m.group('years'))
        months = to_f(m.group('months'))
        weeks = to_f(m.group('weeks'))
        days_ = to_f(m.group('days'))
        hours = to_f(m.group('hours'))
        minutes = to_f(m.group('minutes'))
        seconds = to_f(m.group('seconds'))
        total_days = years * 360 + months * 30 + weeks * 7 + days_
        total_seconds = total_days * 86400 + hours * 3600 + minutes * 60 + seconds
        total_seconds *= sign
        td = timedelta(seconds=total_seconds)
        return cls(td)

==========

### neo4j_extension\types\_abc.py
from __future__ import annotations
from abc import ABC, abstractmethod
from typing import Generic, LiteralString, TypeVar
T = TypeVar('T')

class Neo4jType(ABC, Generic[T]):
    """
    Base class for Python representations of specific types
    that can be stored in or returned from Neo4j via Neo4j.
    """
    value: T

    @abstractmethod
    def to_cypher(self) -> LiteralString:
        """
        Serialize this Python object into a valid Neo4j literal (or function call).
        """

    @classmethod
    @abstractmethod
    def from_cypher(cls, cypher_str: str) -> Neo4jType:
        """
        Parse/deserialize a Neo4j literal (or function call) into this Python object.
        """

    def __repr__(self) -> LiteralString:
        return self.to_cypher()

    def __str__(self) -> str:
        return str(self.value)

    def __eq__(self, other: object) -> bool:
        return isinstance(other, self.__class__) and self.value == getattr(other, 'value', None)

==========

### neo4j_extension\types\_utils.py
from datetime import date, datetime, time, timedelta
from typing import Dict as PyDict
from typing import List as PyList
from typing import LiteralString, Union
from ._abc import Neo4jType
from .primitive import Neo4jBoolean, Neo4jByteArray, Neo4jFloat, Neo4jInteger, Neo4jList, Neo4jMap, Neo4jNull, Neo4jString
from .spatial import Neo4jPoint
from .temporal import Neo4jDate, Neo4jDuration, Neo4jLocalDateTime, Neo4jLocalTime, Neo4jZonedDateTime, Neo4jZonedTime
PythonType = Union[Union[None, bool, int, float, str, date, datetime, time, timedelta, bytes], PyList['PythonType'], PyDict[str, 'PythonType']]

def convert_cypher_to_neo4j(expr: str) -> Neo4jType:
    """
    Convert a Cypher expression to a Neo4jType object.
    """
    expr_strip = expr.strip().lower()
    if expr_strip == 'null':
        return Neo4jNull()
    if expr_strip in ('true', 'false'):
        return Neo4jBoolean.from_cypher(expr_strip)
    try:
        ival = int(expr_strip)
        return Neo4jInteger(ival)
    except ValueError:
        pass
    try:
        return Neo4jFloat.from_cypher(expr_strip)
    except ValueError:
        pass
    try:
        return Neo4jString.from_cypher(expr)
    except ValueError:
        pass
    for cls_candidate in (Neo4jDate, Neo4jLocalTime, Neo4jLocalDateTime, Neo4jZonedTime, Neo4jZonedDateTime, Neo4jDuration, Neo4jPoint, Neo4jByteArray):
        try:
            return cls_candidate.from_cypher(expr)
        except ValueError:
            pass
        except NotImplementedError:
            pass
    try:
        return Neo4jList.from_cypher(expr)
    except ValueError:
        pass
    try:
        return Neo4jMap.from_cypher(expr)
    except ValueError:
        pass
    raise ValueError(f'Could not parse expression as any known Neo4j type: {expr}')

def convert_neo4j_to_python(value: Neo4jType) -> PythonType:
    """
    Convert a Neo4jType object to a Python basic type.
    """
    if isinstance(value, Neo4jNull):
        return None
    if isinstance(value, Neo4jList):
        return [convert_neo4j_to_python(v) for v in value.value]
    if isinstance(value, Neo4jMap):
        py_map = {}
        for k, v in value.value.items():
            py_map[k] = convert_neo4j_to_python(v)
        return py_map
    return value.value

def convert_python_to_neo4j(value: PythonType) -> Neo4jType:
    """
    Convert a Python basic type to a Neo4jType object.
    """
    if value is None:
        return Neo4jNull()
    if isinstance(value, bool):
        return Neo4jBoolean(value)
    if isinstance(value, int):
        return Neo4jInteger(value)
    if isinstance(value, float):
        return Neo4jFloat(value)
    if isinstance(value, str):
        return Neo4jString(value)
    if isinstance(value, date) and (not isinstance(value, datetime)):
        return Neo4jDate(value)
    if isinstance(value, datetime):
        if value.tzinfo is None:
            return Neo4jLocalDateTime(value)
        else:
            return Neo4jZonedDateTime(value)
    if isinstance(value, time) and (not isinstance(value, datetime)):
        if value.tzinfo is None:
            return Neo4jLocalTime(value)
        else:
            return Neo4jZonedTime(value)
    if isinstance(value, timedelta):
        return Neo4jDuration(value)
    if isinstance(value, bytes):
        return Neo4jByteArray(value)
    if isinstance(value, list):
        converted = [ensure_neo4j_type(v) for v in value]
        return Neo4jList(converted)
    if isinstance(value, dict):
        conv_map = {}
        for k, v in value.items():
            if not isinstance(k, str):
                raise TypeError(f'Map key must be str, got {k}')
            conv_map[k] = ensure_neo4j_type(v)
        return Neo4jMap(conv_map)
    raise TypeError(f'[ensure_neo4j_type] 변환 불가한 값: {repr(value)}')

def ensure_neo4j_type(value: Union[Neo4jType, PythonType]) -> Neo4jType:
    """
    Assert that the given value is a Neo4jType.

    If the value is already a Neo4jType, it is returned as is.
    If the value is a Python basic type, it is converted to a Neo4jType.
    """
    if isinstance(value, Neo4jType):
        return value
    return convert_python_to_neo4j(value)

def ensure_python_type(value: Union[Neo4jType, PythonType]) -> PythonType:
    """
    Assert that the given value is a Python basic type.

    If the value is a Python basic type, it is returned as is.
    If the value is a Neo4jType, it is converted to a Python basic type.
    """
    if isinstance(value, Neo4jType):
        return convert_neo4j_to_python(value)
    return value

def get_neo4j_property_type_name(val: Neo4jType) -> LiteralString:
    """
    Return the name of the Neo4j property type for the given value.
    """
    if isinstance(val, Neo4jNull):
        return 'null'
    if isinstance(val, Neo4jBoolean):
        return 'boolean'
    if isinstance(val, Neo4jInteger):
        return 'integer'
    if isinstance(val, Neo4jFloat):
        return 'float'
    if isinstance(val, Neo4jString):
        return 'string'
    if isinstance(val, Neo4jDate):
        return 'date'
    if isinstance(val, Neo4jLocalTime):
        return 'time'
    if isinstance(val, Neo4jLocalDateTime):
        return 'datetime'
    if isinstance(val, Neo4jZonedTime):
        return 'time'
    if isinstance(val, Neo4jZonedDateTime):
        return 'datetime'
    if isinstance(val, Neo4jDuration):
        return 'duration'
    if isinstance(val, Neo4jPoint):
        return 'point'
    if isinstance(val, Neo4jByteArray):
        return 'bytearray'
    if isinstance(val, Neo4jList):
        return 'list'
    return 'other'

==========

### neo4j_extension\types\__init__.py
from ._abc import Neo4jType
from ._utils import PythonType, convert_cypher_to_neo4j, convert_neo4j_to_python, convert_python_to_neo4j, ensure_neo4j_type, ensure_python_type, get_neo4j_property_type_name
from .primitive import Neo4jBoolean, Neo4jByteArray, Neo4jFloat, Neo4jInteger, Neo4jList, Neo4jMap, Neo4jNull, Neo4jString
from .spatial import Neo4jPoint, PointValue
from .temporal import Neo4jDate, Neo4jDuration, Neo4jLocalDateTime, Neo4jLocalTime, Neo4jZonedDateTime, Neo4jZonedTime
__all__ = ['Neo4jBoolean', 'Neo4jByteArray', 'Neo4jFloat', 'Neo4jInteger', 'Neo4jList', 'Neo4jMap', 'Neo4jNull', 'Neo4jString', 'Neo4jPoint', 'PointValue', 'Neo4jDate', 'Neo4jDuration', 'Neo4jType', 'Neo4jLocalDateTime', 'Neo4jLocalTime', 'Neo4jZonedDateTime', 'Neo4jZonedTime', 'PythonType', 'convert_neo4j_to_python', 'ensure_neo4j_type', 'get_neo4j_property_type_name', 'convert_cypher_to_neo4j', 'convert_python_to_neo4j', 'ensure_python_type', 'Neo4jBoolean', 'Neo4jByteArray', 'Neo4jFloat', 'Neo4jInteger', 'Neo4jList', 'Neo4jMap', 'Neo4jNull', 'Neo4jString', 'Neo4jPoint', 'PointValue', 'Neo4jDate', 'Neo4jDuration', 'Neo4jType', 'Neo4jLocalDateTime', 'Neo4jLocalTime', 'Neo4jZonedDateTime', 'Neo4jZonedTime', 'PythonType', 'convert_neo4j_to_python', 'ensure_neo4j_type', 'get_neo4j_property_type_name', 'convert_cypher_to_neo4j', 'convert_python_to_neo4j', 'ensure_python_type']

==========

